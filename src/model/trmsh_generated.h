// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRMSH_TITAN_MODEL_H_
#define FLATBUFFERS_GENERATED_TRMSH_TITAN_MODEL_H_

#include "flatbuffers/flatbuffers.h"
#include "common.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Titan {
namespace Model {

struct Sphere;

struct BoundingBox;
struct BoundingBoxBuilder;

struct Influence;
struct InfluenceBuilder;

struct VertexAccessor;
struct VertexAccessorBuilder;

struct VertexSize;
struct VertexSizeBuilder;

struct VertexAccessors;
struct VertexAccessorsBuilder;

struct MaterialInfo;
struct MaterialInfoBuilder;

struct MorphAccessor;
struct MorphAccessorBuilder;

struct MorphSize;
struct MorphSizeBuilder;

struct MorphData;
struct MorphDataBuilder;

struct MorphMetaData;
struct MorphMetaDataBuilder;

struct MorphShape;
struct MorphShapeBuilder;

struct VisShape;
struct VisShapeBuilder;

struct MeshShape;
struct MeshShapeBuilder;

struct TRMSH;
struct TRMSHBuilder;

enum VertexAttribute : uint32_t {
  VertexAttribute_NONE = 0,
  VertexAttribute_POSITION = 1,
  VertexAttribute_NORMAL = 2,
  VertexAttribute_TANGENT = 3,
  VertexAttribute_BINORMAL = 4,
  VertexAttribute_COLOR = 5,
  VertexAttribute_TEXCOORD = 6,
  VertexAttribute_BLEND_INDICES = 7,
  VertexAttribute_BLEND_WEIGHTS = 8,
  VertexAttribute_USER = 9,
  VertexAttribute_USER_ID = 10,
  VertexAttribute_MIN = VertexAttribute_NONE,
  VertexAttribute_MAX = VertexAttribute_USER_ID
};

inline const VertexAttribute (&EnumValuesVertexAttribute())[11] {
  static const VertexAttribute values[] = {
    VertexAttribute_NONE,
    VertexAttribute_POSITION,
    VertexAttribute_NORMAL,
    VertexAttribute_TANGENT,
    VertexAttribute_BINORMAL,
    VertexAttribute_COLOR,
    VertexAttribute_TEXCOORD,
    VertexAttribute_BLEND_INDICES,
    VertexAttribute_BLEND_WEIGHTS,
    VertexAttribute_USER,
    VertexAttribute_USER_ID
  };
  return values;
}

inline const char * const *EnumNamesVertexAttribute() {
  static const char * const names[12] = {
    "NONE",
    "POSITION",
    "NORMAL",
    "TANGENT",
    "BINORMAL",
    "COLOR",
    "TEXCOORD",
    "BLEND_INDICES",
    "BLEND_WEIGHTS",
    "USER",
    "USER_ID",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexAttribute(VertexAttribute e) {
  if (::flatbuffers::IsOutRange(e, VertexAttribute_NONE, VertexAttribute_USER_ID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVertexAttribute()[index];
}

enum MorphAttribute : uint32_t {
  MorphAttribute_NONE = 0,
  MorphAttribute_POSITION = 1,
  MorphAttribute_MIN_LIMIT = 2,
  MorphAttribute_MAX_LIMIT = 3,
  MorphAttribute_USER_ID = 10,
  MorphAttribute_MIN = MorphAttribute_NONE,
  MorphAttribute_MAX = MorphAttribute_USER_ID
};

inline const MorphAttribute (&EnumValuesMorphAttribute())[5] {
  static const MorphAttribute values[] = {
    MorphAttribute_NONE,
    MorphAttribute_POSITION,
    MorphAttribute_MIN_LIMIT,
    MorphAttribute_MAX_LIMIT,
    MorphAttribute_USER_ID
  };
  return values;
}

inline const char * const *EnumNamesMorphAttribute() {
  static const char * const names[12] = {
    "NONE",
    "POSITION",
    "MIN_LIMIT",
    "MAX_LIMIT",
    "",
    "",
    "",
    "",
    "",
    "",
    "USER_ID",
    nullptr
  };
  return names;
}

inline const char *EnumNameMorphAttribute(MorphAttribute e) {
  if (::flatbuffers::IsOutRange(e, MorphAttribute_NONE, MorphAttribute_USER_ID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMorphAttribute()[index];
}

enum Type : uint32_t {
  Type_NONE = 0,
  Type_RGBA_8_UNORM = 20,
  Type_RGBA_8_UNSIGNED = 22,
  Type_R_32_UINT = 36,
  Type_R_32_INT = 37,
  Type_RGBA_16_UNORM = 39,
  Type_RGBA_16_FLOAT = 43,
  Type_RG_32_FLOAT = 48,
  Type_RGB_32_FLOAT = 51,
  Type_RGBA_32_FLOAT = 54,
  Type_MIN = Type_NONE,
  Type_MAX = Type_RGBA_32_FLOAT
};

inline const Type (&EnumValuesType())[10] {
  static const Type values[] = {
    Type_NONE,
    Type_RGBA_8_UNORM,
    Type_RGBA_8_UNSIGNED,
    Type_R_32_UINT,
    Type_R_32_INT,
    Type_RGBA_16_UNORM,
    Type_RGBA_16_FLOAT,
    Type_RG_32_FLOAT,
    Type_RGB_32_FLOAT,
    Type_RGBA_32_FLOAT
  };
  return values;
}

inline const char *EnumNameType(Type e) {
  switch (e) {
    case Type_NONE: return "NONE";
    case Type_RGBA_8_UNORM: return "RGBA_8_UNORM";
    case Type_RGBA_8_UNSIGNED: return "RGBA_8_UNSIGNED";
    case Type_R_32_UINT: return "R_32_UINT";
    case Type_R_32_INT: return "R_32_INT";
    case Type_RGBA_16_UNORM: return "RGBA_16_UNORM";
    case Type_RGBA_16_FLOAT: return "RGBA_16_FLOAT";
    case Type_RG_32_FLOAT: return "RG_32_FLOAT";
    case Type_RGB_32_FLOAT: return "RGB_32_FLOAT";
    case Type_RGBA_32_FLOAT: return "RGBA_32_FLOAT";
    default: return "";
  }
}

enum PolygonType : uint32_t {
  PolygonType_UINT8 = 0,
  PolygonType_UINT16 = 1,
  PolygonType_UINT32 = 2,
  PolygonType_UINT64 = 3,
  PolygonType_MIN = PolygonType_UINT8,
  PolygonType_MAX = PolygonType_UINT64
};

inline const PolygonType (&EnumValuesPolygonType())[4] {
  static const PolygonType values[] = {
    PolygonType_UINT8,
    PolygonType_UINT16,
    PolygonType_UINT32,
    PolygonType_UINT64
  };
  return values;
}

inline const char * const *EnumNamesPolygonType() {
  static const char * const names[5] = {
    "UINT8",
    "UINT16",
    "UINT32",
    "UINT64",
    nullptr
  };
  return names;
}

inline const char *EnumNamePolygonType(PolygonType e) {
  if (::flatbuffers::IsOutRange(e, PolygonType_UINT8, PolygonType_UINT64)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPolygonType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Sphere FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float radius_;

 public:
  Sphere()
      : x_(0),
        y_(0),
        z_(0),
        radius_(0) {
  }
  Sphere(float _x, float _y, float _z, float _radius)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        radius_(::flatbuffers::EndianScalar(_radius)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float radius() const {
    return ::flatbuffers::EndianScalar(radius_);
  }
};
FLATBUFFERS_STRUCT_END(Sphere, 16);

struct BoundingBox FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoundingBoxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6
  };
  const Titan::Model::Vec3 *min() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_MIN);
  }
  const Titan::Model::Vec3 *max() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_MAX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_MIN, 4) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_MAX, 4) &&
           verifier.EndTable();
  }
};

struct BoundingBoxBuilder {
  typedef BoundingBox Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(const Titan::Model::Vec3 *min) {
    fbb_.AddStruct(BoundingBox::VT_MIN, min);
  }
  void add_max(const Titan::Model::Vec3 *max) {
    fbb_.AddStruct(BoundingBox::VT_MAX, max);
  }
  explicit BoundingBoxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoundingBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoundingBox>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoundingBox> CreateBoundingBox(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Titan::Model::Vec3 *min = nullptr,
    const Titan::Model::Vec3 *max = nullptr) {
  BoundingBoxBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  return builder_.Finish();
}

struct Influence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InfluenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_SCALE = 6
  };
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INDEX, 4) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           verifier.EndTable();
  }
};

struct InfluenceBuilder {
  typedef Influence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(Influence::VT_INDEX, index, 0);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(Influence::VT_SCALE, scale, 0.0f);
  }
  explicit InfluenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Influence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Influence>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Influence> CreateInfluence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t index = 0,
    float scale = 0.0f) {
  InfluenceBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_index(index);
  return builder_.Finish();
}

struct VertexAccessor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VertexAccessorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTR_0 = 4,
    VT_ATTRIBUTE = 6,
    VT_ATTRIBUTE_LAYER = 8,
    VT_TYPE = 10,
    VT_POSITION = 12
  };
  int32_t attr_0() const {
    return GetField<int32_t>(VT_ATTR_0, -1);
  }
  Titan::Model::VertexAttribute attribute() const {
    return static_cast<Titan::Model::VertexAttribute>(GetField<uint32_t>(VT_ATTRIBUTE, 0));
  }
  uint32_t attribute_layer() const {
    return GetField<uint32_t>(VT_ATTRIBUTE_LAYER, 0);
  }
  Titan::Model::Type type() const {
    return static_cast<Titan::Model::Type>(GetField<uint32_t>(VT_TYPE, 0));
  }
  uint32_t position() const {
    return GetField<uint32_t>(VT_POSITION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ATTR_0, 4) &&
           VerifyField<uint32_t>(verifier, VT_ATTRIBUTE, 4) &&
           VerifyField<uint32_t>(verifier, VT_ATTRIBUTE_LAYER, 4) &&
           VerifyField<uint32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<uint32_t>(verifier, VT_POSITION, 4) &&
           verifier.EndTable();
  }
};

struct VertexAccessorBuilder {
  typedef VertexAccessor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_attr_0(int32_t attr_0) {
    fbb_.AddElement<int32_t>(VertexAccessor::VT_ATTR_0, attr_0, -1);
  }
  void add_attribute(Titan::Model::VertexAttribute attribute) {
    fbb_.AddElement<uint32_t>(VertexAccessor::VT_ATTRIBUTE, static_cast<uint32_t>(attribute), 0);
  }
  void add_attribute_layer(uint32_t attribute_layer) {
    fbb_.AddElement<uint32_t>(VertexAccessor::VT_ATTRIBUTE_LAYER, attribute_layer, 0);
  }
  void add_type(Titan::Model::Type type) {
    fbb_.AddElement<uint32_t>(VertexAccessor::VT_TYPE, static_cast<uint32_t>(type), 0);
  }
  void add_position(uint32_t position) {
    fbb_.AddElement<uint32_t>(VertexAccessor::VT_POSITION, position, 0);
  }
  explicit VertexAccessorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VertexAccessor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VertexAccessor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VertexAccessor> CreateVertexAccessor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t attr_0 = -1,
    Titan::Model::VertexAttribute attribute = Titan::Model::VertexAttribute_NONE,
    uint32_t attribute_layer = 0,
    Titan::Model::Type type = Titan::Model::Type_NONE,
    uint32_t position = 0) {
  VertexAccessorBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_type(type);
  builder_.add_attribute_layer(attribute_layer);
  builder_.add_attribute(attribute);
  builder_.add_attr_0(attr_0);
  return builder_.Finish();
}

struct VertexSize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VertexSizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4
  };
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct VertexSizeBuilder {
  typedef VertexSize Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(VertexSize::VT_SIZE, size, 0);
  }
  explicit VertexSizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VertexSize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VertexSize>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VertexSize> CreateVertexSize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t size = 0) {
  VertexSizeBuilder builder_(_fbb);
  builder_.add_size(size);
  return builder_.Finish();
}

struct VertexAccessors FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VertexAccessorsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTRS = 4,
    VT_SIZE = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexAccessor>> *attrs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexAccessor>> *>(VT_ATTRS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexSize>> *size() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexSize>> *>(VT_SIZE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTRS) &&
           verifier.VerifyVector(attrs()) &&
           verifier.VerifyVectorOfTables(attrs()) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyVector(size()) &&
           verifier.VerifyVectorOfTables(size()) &&
           verifier.EndTable();
  }
};

struct VertexAccessorsBuilder {
  typedef VertexAccessors Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_attrs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexAccessor>>> attrs) {
    fbb_.AddOffset(VertexAccessors::VT_ATTRS, attrs);
  }
  void add_size(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexSize>>> size) {
    fbb_.AddOffset(VertexAccessors::VT_SIZE, size);
  }
  explicit VertexAccessorsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VertexAccessors> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VertexAccessors>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VertexAccessors> CreateVertexAccessors(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexAccessor>>> attrs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexSize>>> size = 0) {
  VertexAccessorsBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_attrs(attrs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VertexAccessors> CreateVertexAccessorsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Titan::Model::VertexAccessor>> *attrs = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::VertexSize>> *size = nullptr) {
  auto attrs__ = attrs ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::VertexAccessor>>(*attrs) : 0;
  auto size__ = size ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::VertexSize>>(*size) : 0;
  return Titan::Model::CreateVertexAccessors(
      _fbb,
      attrs__,
      size__);
}

struct MaterialInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaterialInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POLY_COUNT = 4,
    VT_POLY_OFFSET = 6,
    VT_SH_UNK3 = 8,
    VT_MATERIAL_NAME = 10,
    VT_SH_UNK4 = 12
  };
  uint32_t poly_count() const {
    return GetField<uint32_t>(VT_POLY_COUNT, 0);
  }
  uint32_t poly_offset() const {
    return GetField<uint32_t>(VT_POLY_OFFSET, 0);
  }
  uint32_t sh_unk3() const {
    return GetField<uint32_t>(VT_SH_UNK3, 0);
  }
  const ::flatbuffers::String *material_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATERIAL_NAME);
  }
  int32_t sh_unk4() const {
    return GetField<int32_t>(VT_SH_UNK4, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_POLY_COUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_POLY_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_SH_UNK3, 4) &&
           VerifyOffset(verifier, VT_MATERIAL_NAME) &&
           verifier.VerifyString(material_name()) &&
           VerifyField<int32_t>(verifier, VT_SH_UNK4, 4) &&
           verifier.EndTable();
  }
};

struct MaterialInfoBuilder {
  typedef MaterialInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_poly_count(uint32_t poly_count) {
    fbb_.AddElement<uint32_t>(MaterialInfo::VT_POLY_COUNT, poly_count, 0);
  }
  void add_poly_offset(uint32_t poly_offset) {
    fbb_.AddElement<uint32_t>(MaterialInfo::VT_POLY_OFFSET, poly_offset, 0);
  }
  void add_sh_unk3(uint32_t sh_unk3) {
    fbb_.AddElement<uint32_t>(MaterialInfo::VT_SH_UNK3, sh_unk3, 0);
  }
  void add_material_name(::flatbuffers::Offset<::flatbuffers::String> material_name) {
    fbb_.AddOffset(MaterialInfo::VT_MATERIAL_NAME, material_name);
  }
  void add_sh_unk4(int32_t sh_unk4) {
    fbb_.AddElement<int32_t>(MaterialInfo::VT_SH_UNK4, sh_unk4, -1);
  }
  explicit MaterialInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaterialInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaterialInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MaterialInfo> CreateMaterialInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t poly_count = 0,
    uint32_t poly_offset = 0,
    uint32_t sh_unk3 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> material_name = 0,
    int32_t sh_unk4 = -1) {
  MaterialInfoBuilder builder_(_fbb);
  builder_.add_sh_unk4(sh_unk4);
  builder_.add_material_name(material_name);
  builder_.add_sh_unk3(sh_unk3);
  builder_.add_poly_offset(poly_offset);
  builder_.add_poly_count(poly_count);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MaterialInfo> CreateMaterialInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t poly_count = 0,
    uint32_t poly_offset = 0,
    uint32_t sh_unk3 = 0,
    const char *material_name = nullptr,
    int32_t sh_unk4 = -1) {
  auto material_name__ = material_name ? _fbb.CreateString(material_name) : 0;
  return Titan::Model::CreateMaterialInfo(
      _fbb,
      poly_count,
      poly_offset,
      sh_unk3,
      material_name__,
      sh_unk4);
}

struct MorphAccessor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MorphAccessorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNK_0 = 4,
    VT_ATTRIBUTE = 6,
    VT_UNK_1 = 8,
    VT_TYPE = 10,
    VT_POSITION = 12
  };
  uint32_t unk_0() const {
    return GetField<uint32_t>(VT_UNK_0, 0);
  }
  Titan::Model::MorphAttribute attribute() const {
    return static_cast<Titan::Model::MorphAttribute>(GetField<uint32_t>(VT_ATTRIBUTE, 0));
  }
  uint32_t unk_1() const {
    return GetField<uint32_t>(VT_UNK_1, 0);
  }
  Titan::Model::Type type() const {
    return static_cast<Titan::Model::Type>(GetField<uint32_t>(VT_TYPE, 0));
  }
  uint32_t position() const {
    return GetField<uint32_t>(VT_POSITION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UNK_0, 4) &&
           VerifyField<uint32_t>(verifier, VT_ATTRIBUTE, 4) &&
           VerifyField<uint32_t>(verifier, VT_UNK_1, 4) &&
           VerifyField<uint32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<uint32_t>(verifier, VT_POSITION, 4) &&
           verifier.EndTable();
  }
};

struct MorphAccessorBuilder {
  typedef MorphAccessor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_unk_0(uint32_t unk_0) {
    fbb_.AddElement<uint32_t>(MorphAccessor::VT_UNK_0, unk_0, 0);
  }
  void add_attribute(Titan::Model::MorphAttribute attribute) {
    fbb_.AddElement<uint32_t>(MorphAccessor::VT_ATTRIBUTE, static_cast<uint32_t>(attribute), 0);
  }
  void add_unk_1(uint32_t unk_1) {
    fbb_.AddElement<uint32_t>(MorphAccessor::VT_UNK_1, unk_1, 0);
  }
  void add_type(Titan::Model::Type type) {
    fbb_.AddElement<uint32_t>(MorphAccessor::VT_TYPE, static_cast<uint32_t>(type), 0);
  }
  void add_position(uint32_t position) {
    fbb_.AddElement<uint32_t>(MorphAccessor::VT_POSITION, position, 0);
  }
  explicit MorphAccessorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MorphAccessor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MorphAccessor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MorphAccessor> CreateMorphAccessor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t unk_0 = 0,
    Titan::Model::MorphAttribute attribute = Titan::Model::MorphAttribute_NONE,
    uint32_t unk_1 = 0,
    Titan::Model::Type type = Titan::Model::Type_NONE,
    uint32_t position = 0) {
  MorphAccessorBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_type(type);
  builder_.add_unk_1(unk_1);
  builder_.add_attribute(attribute);
  builder_.add_unk_0(unk_0);
  return builder_.Finish();
}

struct MorphSize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MorphSizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4
  };
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct MorphSizeBuilder {
  typedef MorphSize Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(MorphSize::VT_SIZE, size, 0);
  }
  explicit MorphSizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MorphSize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MorphSize>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MorphSize> CreateMorphSize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t size = 0) {
  MorphSizeBuilder builder_(_fbb);
  builder_.add_size(size);
  return builder_.Finish();
}

struct MorphData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MorphDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTRS = 4,
    VT_SIZE = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphAccessor>> *attrs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphAccessor>> *>(VT_ATTRS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphSize>> *size() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphSize>> *>(VT_SIZE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTRS) &&
           verifier.VerifyVector(attrs()) &&
           verifier.VerifyVectorOfTables(attrs()) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyVector(size()) &&
           verifier.VerifyVectorOfTables(size()) &&
           verifier.EndTable();
  }
};

struct MorphDataBuilder {
  typedef MorphData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_attrs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphAccessor>>> attrs) {
    fbb_.AddOffset(MorphData::VT_ATTRS, attrs);
  }
  void add_size(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphSize>>> size) {
    fbb_.AddOffset(MorphData::VT_SIZE, size);
  }
  explicit MorphDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MorphData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MorphData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MorphData> CreateMorphData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphAccessor>>> attrs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphSize>>> size = 0) {
  MorphDataBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_attrs(attrs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MorphData> CreateMorphDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Titan::Model::MorphAccessor>> *attrs = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::MorphSize>> *size = nullptr) {
  auto attrs__ = attrs ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MorphAccessor>>(*attrs) : 0;
  auto size__ = size ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MorphSize>>(*size) : 0;
  return Titan::Model::CreateMorphData(
      _fbb,
      attrs__,
      size__);
}

struct MorphMetaData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MorphMetaDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MORPH_INDEX = 4,
    VT_MORPH_NAME = 6,
    VT_MORPH_TYPE = 8
  };
  uint32_t morph_index() const {
    return GetField<uint32_t>(VT_MORPH_INDEX, 0);
  }
  const ::flatbuffers::String *morph_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MORPH_NAME);
  }
  uint8_t morph_type() const {
    return GetField<uint8_t>(VT_MORPH_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MORPH_INDEX, 4) &&
           VerifyOffset(verifier, VT_MORPH_NAME) &&
           verifier.VerifyString(morph_name()) &&
           VerifyField<uint8_t>(verifier, VT_MORPH_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct MorphMetaDataBuilder {
  typedef MorphMetaData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_morph_index(uint32_t morph_index) {
    fbb_.AddElement<uint32_t>(MorphMetaData::VT_MORPH_INDEX, morph_index, 0);
  }
  void add_morph_name(::flatbuffers::Offset<::flatbuffers::String> morph_name) {
    fbb_.AddOffset(MorphMetaData::VT_MORPH_NAME, morph_name);
  }
  void add_morph_type(uint8_t morph_type) {
    fbb_.AddElement<uint8_t>(MorphMetaData::VT_MORPH_TYPE, morph_type, 0);
  }
  explicit MorphMetaDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MorphMetaData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MorphMetaData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MorphMetaData> CreateMorphMetaData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t morph_index = 0,
    ::flatbuffers::Offset<::flatbuffers::String> morph_name = 0,
    uint8_t morph_type = 0) {
  MorphMetaDataBuilder builder_(_fbb);
  builder_.add_morph_name(morph_name);
  builder_.add_morph_index(morph_index);
  builder_.add_morph_type(morph_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MorphMetaData> CreateMorphMetaDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t morph_index = 0,
    const char *morph_name = nullptr,
    uint8_t morph_type = 0) {
  auto morph_name__ = morph_name ? _fbb.CreateString(morph_name) : 0;
  return Titan::Model::CreateMorphMetaData(
      _fbb,
      morph_index,
      morph_name__,
      morph_type);
}

struct MorphShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MorphShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4,
    VT_METADATA = 6,
    VT_MORPH_NAME = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphData>> *data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphData>> *>(VT_DATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphMetaData>> *metadata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphMetaData>> *>(VT_METADATA);
  }
  const ::flatbuffers::String *morph_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MORPH_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) &&
           VerifyOffset(verifier, VT_MORPH_NAME) &&
           verifier.VerifyString(morph_name()) &&
           verifier.EndTable();
  }
};

struct MorphShapeBuilder {
  typedef MorphShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphData>>> data) {
    fbb_.AddOffset(MorphShape::VT_DATA, data);
  }
  void add_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphMetaData>>> metadata) {
    fbb_.AddOffset(MorphShape::VT_METADATA, metadata);
  }
  void add_morph_name(::flatbuffers::Offset<::flatbuffers::String> morph_name) {
    fbb_.AddOffset(MorphShape::VT_MORPH_NAME, morph_name);
  }
  explicit MorphShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MorphShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MorphShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MorphShape> CreateMorphShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphData>>> data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphMetaData>>> metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> morph_name = 0) {
  MorphShapeBuilder builder_(_fbb);
  builder_.add_morph_name(morph_name);
  builder_.add_metadata(metadata);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MorphShape> CreateMorphShapeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Titan::Model::MorphData>> *data = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::MorphMetaData>> *metadata = nullptr,
    const char *morph_name = nullptr) {
  auto data__ = data ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MorphData>>(*data) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MorphMetaData>>(*metadata) : 0;
  auto morph_name__ = morph_name ? _fbb.CreateString(morph_name) : 0;
  return Titan::Model::CreateMorphShape(
      _fbb,
      data__,
      metadata__,
      morph_name__);
}

struct VisShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VisShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_NAME = 6
  };
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INDEX, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct VisShapeBuilder {
  typedef VisShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(VisShape::VT_INDEX, index, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(VisShape::VT_NAME, name);
  }
  explicit VisShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VisShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VisShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VisShape> CreateVisShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t index = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  VisShapeBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_index(index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VisShape> CreateVisShapeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t index = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Titan::Model::CreateVisShape(
      _fbb,
      index,
      name__);
}

struct MeshShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MeshShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESH_SHAPE_NAME = 4,
    VT_BOUNDS = 6,
    VT_POLYGON_TYPE = 8,
    VT_ATTRIBUTES = 10,
    VT_MATERIALS = 12,
    VT_RES0 = 14,
    VT_RES1 = 16,
    VT_RES2 = 18,
    VT_RES3 = 20,
    VT_CLIP_SPHERE = 22,
    VT_INFLUENCE = 24,
    VT_VIS_SHAPES = 26,
    VT_MESH_NAME = 28,
    VT_UNK13 = 30,
    VT_MORPH_SHAPE = 32
  };
  const ::flatbuffers::String *mesh_shape_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESH_SHAPE_NAME);
  }
  const Titan::Model::BoundingBox *bounds() const {
    return GetPointer<const Titan::Model::BoundingBox *>(VT_BOUNDS);
  }
  Titan::Model::PolygonType polygon_type() const {
    return static_cast<Titan::Model::PolygonType>(GetField<uint32_t>(VT_POLYGON_TYPE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexAccessors>> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexAccessors>> *>(VT_ATTRIBUTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialInfo>> *materials() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialInfo>> *>(VT_MATERIALS);
  }
  uint32_t res0() const {
    return GetField<uint32_t>(VT_RES0, 0);
  }
  uint32_t res1() const {
    return GetField<uint32_t>(VT_RES1, 0);
  }
  uint32_t res2() const {
    return GetField<uint32_t>(VT_RES2, 0);
  }
  uint32_t res3() const {
    return GetField<uint32_t>(VT_RES3, 0);
  }
  const Titan::Model::Sphere *clip_sphere() const {
    return GetStruct<const Titan::Model::Sphere *>(VT_CLIP_SPHERE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Influence>> *influence() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Influence>> *>(VT_INFLUENCE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VisShape>> *vis_shapes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VisShape>> *>(VT_VIS_SHAPES);
  }
  const ::flatbuffers::String *mesh_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESH_NAME);
  }
  uint32_t unk13() const {
    return GetField<uint32_t>(VT_UNK13, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphShape>> *morph_shape() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphShape>> *>(VT_MORPH_SHAPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESH_SHAPE_NAME) &&
           verifier.VerifyString(mesh_shape_name()) &&
           VerifyOffset(verifier, VT_BOUNDS) &&
           verifier.VerifyTable(bounds()) &&
           VerifyField<uint32_t>(verifier, VT_POLYGON_TYPE, 4) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           verifier.VerifyVectorOfTables(materials()) &&
           VerifyField<uint32_t>(verifier, VT_RES0, 4) &&
           VerifyField<uint32_t>(verifier, VT_RES1, 4) &&
           VerifyField<uint32_t>(verifier, VT_RES2, 4) &&
           VerifyField<uint32_t>(verifier, VT_RES3, 4) &&
           VerifyField<Titan::Model::Sphere>(verifier, VT_CLIP_SPHERE, 4) &&
           VerifyOffset(verifier, VT_INFLUENCE) &&
           verifier.VerifyVector(influence()) &&
           verifier.VerifyVectorOfTables(influence()) &&
           VerifyOffset(verifier, VT_VIS_SHAPES) &&
           verifier.VerifyVector(vis_shapes()) &&
           verifier.VerifyVectorOfTables(vis_shapes()) &&
           VerifyOffset(verifier, VT_MESH_NAME) &&
           verifier.VerifyString(mesh_name()) &&
           VerifyField<uint32_t>(verifier, VT_UNK13, 4) &&
           VerifyOffset(verifier, VT_MORPH_SHAPE) &&
           verifier.VerifyVector(morph_shape()) &&
           verifier.VerifyVectorOfTables(morph_shape()) &&
           verifier.EndTable();
  }
};

struct MeshShapeBuilder {
  typedef MeshShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mesh_shape_name(::flatbuffers::Offset<::flatbuffers::String> mesh_shape_name) {
    fbb_.AddOffset(MeshShape::VT_MESH_SHAPE_NAME, mesh_shape_name);
  }
  void add_bounds(::flatbuffers::Offset<Titan::Model::BoundingBox> bounds) {
    fbb_.AddOffset(MeshShape::VT_BOUNDS, bounds);
  }
  void add_polygon_type(Titan::Model::PolygonType polygon_type) {
    fbb_.AddElement<uint32_t>(MeshShape::VT_POLYGON_TYPE, static_cast<uint32_t>(polygon_type), 0);
  }
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexAccessors>>> attributes) {
    fbb_.AddOffset(MeshShape::VT_ATTRIBUTES, attributes);
  }
  void add_materials(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialInfo>>> materials) {
    fbb_.AddOffset(MeshShape::VT_MATERIALS, materials);
  }
  void add_res0(uint32_t res0) {
    fbb_.AddElement<uint32_t>(MeshShape::VT_RES0, res0, 0);
  }
  void add_res1(uint32_t res1) {
    fbb_.AddElement<uint32_t>(MeshShape::VT_RES1, res1, 0);
  }
  void add_res2(uint32_t res2) {
    fbb_.AddElement<uint32_t>(MeshShape::VT_RES2, res2, 0);
  }
  void add_res3(uint32_t res3) {
    fbb_.AddElement<uint32_t>(MeshShape::VT_RES3, res3, 0);
  }
  void add_clip_sphere(const Titan::Model::Sphere *clip_sphere) {
    fbb_.AddStruct(MeshShape::VT_CLIP_SPHERE, clip_sphere);
  }
  void add_influence(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Influence>>> influence) {
    fbb_.AddOffset(MeshShape::VT_INFLUENCE, influence);
  }
  void add_vis_shapes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VisShape>>> vis_shapes) {
    fbb_.AddOffset(MeshShape::VT_VIS_SHAPES, vis_shapes);
  }
  void add_mesh_name(::flatbuffers::Offset<::flatbuffers::String> mesh_name) {
    fbb_.AddOffset(MeshShape::VT_MESH_NAME, mesh_name);
  }
  void add_unk13(uint32_t unk13) {
    fbb_.AddElement<uint32_t>(MeshShape::VT_UNK13, unk13, 0);
  }
  void add_morph_shape(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphShape>>> morph_shape) {
    fbb_.AddOffset(MeshShape::VT_MORPH_SHAPE, morph_shape);
  }
  explicit MeshShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MeshShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MeshShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MeshShape> CreateMeshShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> mesh_shape_name = 0,
    ::flatbuffers::Offset<Titan::Model::BoundingBox> bounds = 0,
    Titan::Model::PolygonType polygon_type = Titan::Model::PolygonType_UINT8,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VertexAccessors>>> attributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialInfo>>> materials = 0,
    uint32_t res0 = 0,
    uint32_t res1 = 0,
    uint32_t res2 = 0,
    uint32_t res3 = 0,
    const Titan::Model::Sphere *clip_sphere = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Influence>>> influence = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::VisShape>>> vis_shapes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mesh_name = 0,
    uint32_t unk13 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphShape>>> morph_shape = 0) {
  MeshShapeBuilder builder_(_fbb);
  builder_.add_morph_shape(morph_shape);
  builder_.add_unk13(unk13);
  builder_.add_mesh_name(mesh_name);
  builder_.add_vis_shapes(vis_shapes);
  builder_.add_influence(influence);
  builder_.add_clip_sphere(clip_sphere);
  builder_.add_res3(res3);
  builder_.add_res2(res2);
  builder_.add_res1(res1);
  builder_.add_res0(res0);
  builder_.add_materials(materials);
  builder_.add_attributes(attributes);
  builder_.add_polygon_type(polygon_type);
  builder_.add_bounds(bounds);
  builder_.add_mesh_shape_name(mesh_shape_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MeshShape> CreateMeshShapeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *mesh_shape_name = nullptr,
    ::flatbuffers::Offset<Titan::Model::BoundingBox> bounds = 0,
    Titan::Model::PolygonType polygon_type = Titan::Model::PolygonType_UINT8,
    const std::vector<::flatbuffers::Offset<Titan::Model::VertexAccessors>> *attributes = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::MaterialInfo>> *materials = nullptr,
    uint32_t res0 = 0,
    uint32_t res1 = 0,
    uint32_t res2 = 0,
    uint32_t res3 = 0,
    const Titan::Model::Sphere *clip_sphere = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::Influence>> *influence = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::VisShape>> *vis_shapes = nullptr,
    const char *mesh_name = nullptr,
    uint32_t unk13 = 0,
    const std::vector<::flatbuffers::Offset<Titan::Model::MorphShape>> *morph_shape = nullptr) {
  auto mesh_shape_name__ = mesh_shape_name ? _fbb.CreateString(mesh_shape_name) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::VertexAccessors>>(*attributes) : 0;
  auto materials__ = materials ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MaterialInfo>>(*materials) : 0;
  auto influence__ = influence ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Influence>>(*influence) : 0;
  auto vis_shapes__ = vis_shapes ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::VisShape>>(*vis_shapes) : 0;
  auto mesh_name__ = mesh_name ? _fbb.CreateString(mesh_name) : 0;
  auto morph_shape__ = morph_shape ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MorphShape>>(*morph_shape) : 0;
  return Titan::Model::CreateMeshShape(
      _fbb,
      mesh_shape_name__,
      bounds,
      polygon_type,
      attributes__,
      materials__,
      res0,
      res1,
      res2,
      res3,
      clip_sphere,
      influence__,
      vis_shapes__,
      mesh_name__,
      unk13,
      morph_shape__);
}

struct TRMSH FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRMSHBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNK0 = 4,
    VT_MESHES = 6,
    VT_BUFFER_NAME = 8
  };
  uint32_t unk0() const {
    return GetField<uint32_t>(VT_UNK0, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MeshShape>> *meshes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MeshShape>> *>(VT_MESHES);
  }
  const ::flatbuffers::String *buffer_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BUFFER_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UNK0, 4) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           VerifyOffset(verifier, VT_BUFFER_NAME) &&
           verifier.VerifyString(buffer_name()) &&
           verifier.EndTable();
  }
};

struct TRMSHBuilder {
  typedef TRMSH Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_unk0(uint32_t unk0) {
    fbb_.AddElement<uint32_t>(TRMSH::VT_UNK0, unk0, 0);
  }
  void add_meshes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MeshShape>>> meshes) {
    fbb_.AddOffset(TRMSH::VT_MESHES, meshes);
  }
  void add_buffer_name(::flatbuffers::Offset<::flatbuffers::String> buffer_name) {
    fbb_.AddOffset(TRMSH::VT_BUFFER_NAME, buffer_name);
  }
  explicit TRMSHBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TRMSH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TRMSH>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TRMSH> CreateTRMSH(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t unk0 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MeshShape>>> meshes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> buffer_name = 0) {
  TRMSHBuilder builder_(_fbb);
  builder_.add_buffer_name(buffer_name);
  builder_.add_meshes(meshes);
  builder_.add_unk0(unk0);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TRMSH> CreateTRMSHDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t unk0 = 0,
    const std::vector<::flatbuffers::Offset<Titan::Model::MeshShape>> *meshes = nullptr,
    const char *buffer_name = nullptr) {
  auto meshes__ = meshes ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MeshShape>>(*meshes) : 0;
  auto buffer_name__ = buffer_name ? _fbb.CreateString(buffer_name) : 0;
  return Titan::Model::CreateTRMSH(
      _fbb,
      unk0,
      meshes__,
      buffer_name__);
}

inline const Titan::Model::TRMSH *GetTRMSH(const void *buf) {
  return ::flatbuffers::GetRoot<Titan::Model::TRMSH>(buf);
}

inline const Titan::Model::TRMSH *GetSizePrefixedTRMSH(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Titan::Model::TRMSH>(buf);
}

inline bool VerifyTRMSHBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Titan::Model::TRMSH>(nullptr);
}

inline bool VerifySizePrefixedTRMSHBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Titan::Model::TRMSH>(nullptr);
}

inline const char *TRMSHExtension() {
  return "trmsh";
}

inline void FinishTRMSHBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRMSH> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTRMSHBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRMSH> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Model
}  // namespace Titan

#endif  // FLATBUFFERS_GENERATED_TRMSH_TITAN_MODEL_H_
