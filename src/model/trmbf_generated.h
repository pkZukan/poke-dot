// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRMBF_TITAN_MODEL_H_
#define FLATBUFFERS_GENERATED_TRMBF_TITAN_MODEL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Titan {
namespace Model {

struct Indexes;
struct IndexesBuilder;

struct Vertices;
struct VerticesBuilder;

struct MorphBuffer;
struct MorphBufferBuilder;

struct Morphs;
struct MorphsBuilder;

struct Buffer;
struct BufferBuilder;

struct TRMBF;
struct TRMBFBuilder;

struct Indexes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IndexesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  const ::flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.EndTable();
  }
};

struct IndexesBuilder {
  typedef Indexes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_buffer(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(Indexes::VT_BUFFER, buffer);
  }
  explicit IndexesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Indexes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Indexes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Indexes> CreateIndexes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer = 0) {
  IndexesBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Indexes> CreateIndexesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0;
  return Titan::Model::CreateIndexes(
      _fbb,
      buffer__);
}

struct Vertices FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VerticesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  const ::flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.EndTable();
  }
};

struct VerticesBuilder {
  typedef Vertices Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_buffer(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(Vertices::VT_BUFFER, buffer);
  }
  explicit VerticesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vertices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vertices>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vertices> CreateVertices(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer = 0) {
  VerticesBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Vertices> CreateVerticesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0;
  return Titan::Model::CreateVertices(
      _fbb,
      buffer__);
}

struct MorphBuffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MorphBufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  const ::flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.EndTable();
  }
};

struct MorphBufferBuilder {
  typedef MorphBuffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_buffer(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(MorphBuffer::VT_BUFFER, buffer);
  }
  explicit MorphBufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MorphBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MorphBuffer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MorphBuffer> CreateMorphBuffer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer = 0) {
  MorphBufferBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MorphBuffer> CreateMorphBufferDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0;
  return Titan::Model::CreateMorphBuffer(
      _fbb,
      buffer__);
}

struct Morphs FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MorphsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MORPH_BUFFER = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphBuffer>> *morph_buffer() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphBuffer>> *>(VT_MORPH_BUFFER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MORPH_BUFFER) &&
           verifier.VerifyVector(morph_buffer()) &&
           verifier.VerifyVectorOfTables(morph_buffer()) &&
           verifier.EndTable();
  }
};

struct MorphsBuilder {
  typedef Morphs Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_morph_buffer(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphBuffer>>> morph_buffer) {
    fbb_.AddOffset(Morphs::VT_MORPH_BUFFER, morph_buffer);
  }
  explicit MorphsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Morphs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Morphs>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Morphs> CreateMorphs(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MorphBuffer>>> morph_buffer = 0) {
  MorphsBuilder builder_(_fbb);
  builder_.add_morph_buffer(morph_buffer);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Morphs> CreateMorphsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Titan::Model::MorphBuffer>> *morph_buffer = nullptr) {
  auto morph_buffer__ = morph_buffer ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MorphBuffer>>(*morph_buffer) : 0;
  return Titan::Model::CreateMorphs(
      _fbb,
      morph_buffer__);
}

struct Buffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX_BUFFER = 4,
    VT_VERTEX_BUFFER = 6,
    VT_MORPHS = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Indexes>> *index_buffer() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Indexes>> *>(VT_INDEX_BUFFER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Vertices>> *vertex_buffer() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Vertices>> *>(VT_VERTEX_BUFFER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Morphs>> *morphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Morphs>> *>(VT_MORPHS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDEX_BUFFER) &&
           verifier.VerifyVector(index_buffer()) &&
           verifier.VerifyVectorOfTables(index_buffer()) &&
           VerifyOffset(verifier, VT_VERTEX_BUFFER) &&
           verifier.VerifyVector(vertex_buffer()) &&
           verifier.VerifyVectorOfTables(vertex_buffer()) &&
           VerifyOffset(verifier, VT_MORPHS) &&
           verifier.VerifyVector(morphs()) &&
           verifier.VerifyVectorOfTables(morphs()) &&
           verifier.EndTable();
  }
};

struct BufferBuilder {
  typedef Buffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index_buffer(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Indexes>>> index_buffer) {
    fbb_.AddOffset(Buffer::VT_INDEX_BUFFER, index_buffer);
  }
  void add_vertex_buffer(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Vertices>>> vertex_buffer) {
    fbb_.AddOffset(Buffer::VT_VERTEX_BUFFER, vertex_buffer);
  }
  void add_morphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Morphs>>> morphs) {
    fbb_.AddOffset(Buffer::VT_MORPHS, morphs);
  }
  explicit BufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Buffer> CreateBuffer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Indexes>>> index_buffer = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Vertices>>> vertex_buffer = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Morphs>>> morphs = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_morphs(morphs);
  builder_.add_vertex_buffer(vertex_buffer);
  builder_.add_index_buffer(index_buffer);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Buffer> CreateBufferDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Titan::Model::Indexes>> *index_buffer = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::Vertices>> *vertex_buffer = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::Morphs>> *morphs = nullptr) {
  auto index_buffer__ = index_buffer ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Indexes>>(*index_buffer) : 0;
  auto vertex_buffer__ = vertex_buffer ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Vertices>>(*vertex_buffer) : 0;
  auto morphs__ = morphs ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Morphs>>(*morphs) : 0;
  return Titan::Model::CreateBuffer(
      _fbb,
      index_buffer__,
      vertex_buffer__,
      morphs__);
}

struct TRMBF FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRMBFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNUSED = 4,
    VT_BUFFERS = 6
  };
  uint32_t unused() const {
    return GetField<uint32_t>(VT_UNUSED, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Buffer>> *buffers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Buffer>> *>(VT_BUFFERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UNUSED, 4) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           verifier.EndTable();
  }
};

struct TRMBFBuilder {
  typedef TRMBF Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_unused(uint32_t unused) {
    fbb_.AddElement<uint32_t>(TRMBF::VT_UNUSED, unused, 0);
  }
  void add_buffers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Buffer>>> buffers) {
    fbb_.AddOffset(TRMBF::VT_BUFFERS, buffers);
  }
  explicit TRMBFBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TRMBF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TRMBF>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TRMBF> CreateTRMBF(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t unused = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Buffer>>> buffers = 0) {
  TRMBFBuilder builder_(_fbb);
  builder_.add_buffers(buffers);
  builder_.add_unused(unused);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TRMBF> CreateTRMBFDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t unused = 0,
    const std::vector<::flatbuffers::Offset<Titan::Model::Buffer>> *buffers = nullptr) {
  auto buffers__ = buffers ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Buffer>>(*buffers) : 0;
  return Titan::Model::CreateTRMBF(
      _fbb,
      unused,
      buffers__);
}

inline const Titan::Model::TRMBF *GetTRMBF(const void *buf) {
  return ::flatbuffers::GetRoot<Titan::Model::TRMBF>(buf);
}

inline const Titan::Model::TRMBF *GetSizePrefixedTRMBF(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Titan::Model::TRMBF>(buf);
}

inline bool VerifyTRMBFBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Titan::Model::TRMBF>(nullptr);
}

inline bool VerifySizePrefixedTRMBFBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Titan::Model::TRMBF>(nullptr);
}

inline const char *TRMBFExtension() {
  return "trmbf";
}

inline void FinishTRMBFBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRMBF> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTRMBFBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRMBF> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Model
}  // namespace Titan

#endif  // FLATBUFFERS_GENERATED_TRMBF_TITAN_MODEL_H_
