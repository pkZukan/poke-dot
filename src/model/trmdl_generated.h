// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRMDL_TITAN_MODEL_H_
#define FLATBUFFERS_GENERATED_TRMDL_TITAN_MODEL_H_

#include "flatbuffers/flatbuffers.h"
#include "common.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Titan {
namespace Model {

struct trmeshes;
struct trmeshesBuilder;

struct trskeleton;
struct trskeletonBuilder;

struct LodIndex;
struct LodIndexBuilder;

struct Lod;
struct LodBuilder;

struct Bounds;
struct BoundsBuilder;

struct TRMDL;
struct TRMDLBuilder;

struct trmeshes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef trmeshesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4
  };
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           verifier.EndTable();
  }
};

struct trmeshesBuilder {
  typedef trmeshes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(trmeshes::VT_FILENAME, filename);
  }
  explicit trmeshesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<trmeshes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<trmeshes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<trmeshes> Createtrmeshes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0) {
  trmeshesBuilder builder_(_fbb);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<trmeshes> CreatetrmeshesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return Titan::Model::Createtrmeshes(
      _fbb,
      filename__);
}

struct trskeleton FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef trskeletonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4
  };
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           verifier.EndTable();
  }
};

struct trskeletonBuilder {
  typedef trskeleton Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(trskeleton::VT_FILENAME, filename);
  }
  explicit trskeletonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<trskeleton> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<trskeleton>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<trskeleton> Createtrskeleton(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0) {
  trskeletonBuilder builder_(_fbb);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<trskeleton> CreatetrskeletonDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return Titan::Model::Createtrskeleton(
      _fbb,
      filename__);
}

struct LodIndex FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LodIndexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNK0 = 4
  };
  uint32_t unk0() const {
    return GetField<uint32_t>(VT_UNK0, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UNK0, 4) &&
           verifier.EndTable();
  }
};

struct LodIndexBuilder {
  typedef LodIndex Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_unk0(uint32_t unk0) {
    fbb_.AddElement<uint32_t>(LodIndex::VT_UNK0, unk0, 0);
  }
  explicit LodIndexBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LodIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LodIndex>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LodIndex> CreateLodIndex(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t unk0 = 0) {
  LodIndexBuilder builder_(_fbb);
  builder_.add_unk0(unk0);
  return builder_.Finish();
}

struct Lod FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LodBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_LOD_TYPE = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::LodIndex>> *index() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::LodIndex>> *>(VT_INDEX);
  }
  const ::flatbuffers::String *lod_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOD_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyVector(index()) &&
           verifier.VerifyVectorOfTables(index()) &&
           VerifyOffset(verifier, VT_LOD_TYPE) &&
           verifier.VerifyString(lod_type()) &&
           verifier.EndTable();
  }
};

struct LodBuilder {
  typedef Lod Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::LodIndex>>> index) {
    fbb_.AddOffset(Lod::VT_INDEX, index);
  }
  void add_lod_type(::flatbuffers::Offset<::flatbuffers::String> lod_type) {
    fbb_.AddOffset(Lod::VT_LOD_TYPE, lod_type);
  }
  explicit LodBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Lod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Lod>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Lod> CreateLod(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::LodIndex>>> index = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lod_type = 0) {
  LodBuilder builder_(_fbb);
  builder_.add_lod_type(lod_type);
  builder_.add_index(index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Lod> CreateLodDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Titan::Model::LodIndex>> *index = nullptr,
    const char *lod_type = nullptr) {
  auto index__ = index ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::LodIndex>>(*index) : 0;
  auto lod_type__ = lod_type ? _fbb.CreateString(lod_type) : 0;
  return Titan::Model::CreateLod(
      _fbb,
      index__,
      lod_type__);
}

struct Bounds FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoundsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6
  };
  const Titan::Model::Vec3 *min() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_MIN);
  }
  const Titan::Model::Vec3 *max() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_MAX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_MIN, 4) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_MAX, 4) &&
           verifier.EndTable();
  }
};

struct BoundsBuilder {
  typedef Bounds Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(const Titan::Model::Vec3 *min) {
    fbb_.AddStruct(Bounds::VT_MIN, min);
  }
  void add_max(const Titan::Model::Vec3 *max) {
    fbb_.AddStruct(Bounds::VT_MAX, max);
  }
  explicit BoundsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Bounds> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Bounds>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Bounds> CreateBounds(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Titan::Model::Vec3 *min = nullptr,
    const Titan::Model::Vec3 *max = nullptr) {
  BoundsBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  return builder_.Finish();
}

struct TRMDL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRMDLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNK0 = 4,
    VT_MESHES = 6,
    VT_SKELETON = 8,
    VT_MATERIALS = 10,
    VT_LODS = 12,
    VT_BOUNDS = 14,
    VT_TEX_SPC_LOC = 16,
    VT_TRLTT = 18,
    VT_UNK8 = 20,
    VT_UNK9 = 22
  };
  uint32_t unk0() const {
    return GetField<uint32_t>(VT_UNK0, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::trmeshes>> *meshes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::trmeshes>> *>(VT_MESHES);
  }
  const Titan::Model::trskeleton *skeleton() const {
    return GetPointer<const Titan::Model::trskeleton *>(VT_SKELETON);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *materials() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MATERIALS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Lod>> *lods() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Lod>> *>(VT_LODS);
  }
  const Titan::Model::Bounds *bounds() const {
    return GetPointer<const Titan::Model::Bounds *>(VT_BOUNDS);
  }
  const Titan::Model::Vec4 *tex_spc_loc() const {
    return GetStruct<const Titan::Model::Vec4 *>(VT_TEX_SPC_LOC);
  }
  const ::flatbuffers::String *trltt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRLTT);
  }
  uint32_t unk8() const {
    return GetField<uint32_t>(VT_UNK8, 0);
  }
  uint32_t unk9() const {
    return GetField<uint32_t>(VT_UNK9, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UNK0, 4) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           VerifyOffset(verifier, VT_SKELETON) &&
           verifier.VerifyTable(skeleton()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           verifier.VerifyVectorOfStrings(materials()) &&
           VerifyOffset(verifier, VT_LODS) &&
           verifier.VerifyVector(lods()) &&
           verifier.VerifyVectorOfTables(lods()) &&
           VerifyOffset(verifier, VT_BOUNDS) &&
           verifier.VerifyTable(bounds()) &&
           VerifyField<Titan::Model::Vec4>(verifier, VT_TEX_SPC_LOC, 4) &&
           VerifyOffset(verifier, VT_TRLTT) &&
           verifier.VerifyString(trltt()) &&
           VerifyField<uint32_t>(verifier, VT_UNK8, 4) &&
           VerifyField<uint32_t>(verifier, VT_UNK9, 4) &&
           verifier.EndTable();
  }
};

struct TRMDLBuilder {
  typedef TRMDL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_unk0(uint32_t unk0) {
    fbb_.AddElement<uint32_t>(TRMDL::VT_UNK0, unk0, 0);
  }
  void add_meshes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::trmeshes>>> meshes) {
    fbb_.AddOffset(TRMDL::VT_MESHES, meshes);
  }
  void add_skeleton(::flatbuffers::Offset<Titan::Model::trskeleton> skeleton) {
    fbb_.AddOffset(TRMDL::VT_SKELETON, skeleton);
  }
  void add_materials(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> materials) {
    fbb_.AddOffset(TRMDL::VT_MATERIALS, materials);
  }
  void add_lods(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Lod>>> lods) {
    fbb_.AddOffset(TRMDL::VT_LODS, lods);
  }
  void add_bounds(::flatbuffers::Offset<Titan::Model::Bounds> bounds) {
    fbb_.AddOffset(TRMDL::VT_BOUNDS, bounds);
  }
  void add_tex_spc_loc(const Titan::Model::Vec4 *tex_spc_loc) {
    fbb_.AddStruct(TRMDL::VT_TEX_SPC_LOC, tex_spc_loc);
  }
  void add_trltt(::flatbuffers::Offset<::flatbuffers::String> trltt) {
    fbb_.AddOffset(TRMDL::VT_TRLTT, trltt);
  }
  void add_unk8(uint32_t unk8) {
    fbb_.AddElement<uint32_t>(TRMDL::VT_UNK8, unk8, 0);
  }
  void add_unk9(uint32_t unk9) {
    fbb_.AddElement<uint32_t>(TRMDL::VT_UNK9, unk9, 0);
  }
  explicit TRMDLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TRMDL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TRMDL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TRMDL> CreateTRMDL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t unk0 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::trmeshes>>> meshes = 0,
    ::flatbuffers::Offset<Titan::Model::trskeleton> skeleton = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> materials = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Lod>>> lods = 0,
    ::flatbuffers::Offset<Titan::Model::Bounds> bounds = 0,
    const Titan::Model::Vec4 *tex_spc_loc = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> trltt = 0,
    uint32_t unk8 = 0,
    uint32_t unk9 = 0) {
  TRMDLBuilder builder_(_fbb);
  builder_.add_unk9(unk9);
  builder_.add_unk8(unk8);
  builder_.add_trltt(trltt);
  builder_.add_tex_spc_loc(tex_spc_loc);
  builder_.add_bounds(bounds);
  builder_.add_lods(lods);
  builder_.add_materials(materials);
  builder_.add_skeleton(skeleton);
  builder_.add_meshes(meshes);
  builder_.add_unk0(unk0);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TRMDL> CreateTRMDLDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t unk0 = 0,
    const std::vector<::flatbuffers::Offset<Titan::Model::trmeshes>> *meshes = nullptr,
    ::flatbuffers::Offset<Titan::Model::trskeleton> skeleton = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *materials = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::Lod>> *lods = nullptr,
    ::flatbuffers::Offset<Titan::Model::Bounds> bounds = 0,
    const Titan::Model::Vec4 *tex_spc_loc = nullptr,
    const char *trltt = nullptr,
    uint32_t unk8 = 0,
    uint32_t unk9 = 0) {
  auto meshes__ = meshes ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::trmeshes>>(*meshes) : 0;
  auto materials__ = materials ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*materials) : 0;
  auto lods__ = lods ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Lod>>(*lods) : 0;
  auto trltt__ = trltt ? _fbb.CreateString(trltt) : 0;
  return Titan::Model::CreateTRMDL(
      _fbb,
      unk0,
      meshes__,
      skeleton,
      materials__,
      lods__,
      bounds,
      tex_spc_loc,
      trltt__,
      unk8,
      unk9);
}

inline const Titan::Model::TRMDL *GetTRMDL(const void *buf) {
  return ::flatbuffers::GetRoot<Titan::Model::TRMDL>(buf);
}

inline const Titan::Model::TRMDL *GetSizePrefixedTRMDL(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Titan::Model::TRMDL>(buf);
}

inline bool VerifyTRMDLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Titan::Model::TRMDL>(nullptr);
}

inline bool VerifySizePrefixedTRMDLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Titan::Model::TRMDL>(nullptr);
}

inline const char *TRMDLExtension() {
  return "trmdl";
}

inline void FinishTRMDLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRMDL> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTRMDLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRMDL> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Model
}  // namespace Titan

#endif  // FLATBUFFERS_GENERATED_TRMDL_TITAN_MODEL_H_
