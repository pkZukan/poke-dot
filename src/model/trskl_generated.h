// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRSKL_TITAN_MODEL_H_
#define FLATBUFFERS_GENERATED_TRSKL_TITAN_MODEL_H_

#include "flatbuffers/flatbuffers.h"
#include "common.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Titan {
namespace Model {

struct Transform;
struct TransformBuilder;

struct TransformNode;
struct TransformNodeBuilder;

struct IKControl;
struct IKControlBuilder;

struct BoneMatrix;
struct BoneMatrixBuilder;

struct Bone;
struct BoneBuilder;

struct TRSKL;
struct TRSKLBuilder;

enum NodeType : uint32_t {
  NodeType_Default = 0,
  NodeType_Chained = 1,
  NodeType_Floating = 2,
  NodeType_MIN = NodeType_Default,
  NodeType_MAX = NodeType_Floating
};

inline const NodeType (&EnumValuesNodeType())[3] {
  static const NodeType values[] = {
    NodeType_Default,
    NodeType_Chained,
    NodeType_Floating
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[4] = {
    "Default",
    "Chained",
    "Floating",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  if (::flatbuffers::IsOutRange(e, NodeType_Default, NodeType_Floating)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeType()[index];
}

struct Transform FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransformBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VECSCALE = 4,
    VT_VECROT = 6,
    VT_VECTRANSLATE = 8
  };
  const Titan::Model::Vec3 *VecScale() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_VECSCALE);
  }
  const Titan::Model::Vec3 *VecRot() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_VECROT);
  }
  const Titan::Model::Vec3 *VecTranslate() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_VECTRANSLATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_VECSCALE, 4) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_VECROT, 4) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_VECTRANSLATE, 4) &&
           verifier.EndTable();
  }
};

struct TransformBuilder {
  typedef Transform Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_VecScale(const Titan::Model::Vec3 *VecScale) {
    fbb_.AddStruct(Transform::VT_VECSCALE, VecScale);
  }
  void add_VecRot(const Titan::Model::Vec3 *VecRot) {
    fbb_.AddStruct(Transform::VT_VECROT, VecRot);
  }
  void add_VecTranslate(const Titan::Model::Vec3 *VecTranslate) {
    fbb_.AddStruct(Transform::VT_VECTRANSLATE, VecTranslate);
  }
  explicit TransformBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Transform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Transform>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Transform> CreateTransform(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Titan::Model::Vec3 *VecScale = nullptr,
    const Titan::Model::Vec3 *VecRot = nullptr,
    const Titan::Model::Vec3 *VecTranslate = nullptr) {
  TransformBuilder builder_(_fbb);
  builder_.add_VecTranslate(VecTranslate);
  builder_.add_VecRot(VecRot);
  builder_.add_VecScale(VecScale);
  return builder_.Finish();
}

struct TransformNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransformNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TRANSFORM = 6,
    VT_SCALEPIVOT = 8,
    VT_ROTATEPIVOT = 10,
    VT_PARENT_IDX = 12,
    VT_RIG_IDX = 14,
    VT_EFFECT_NODE = 16,
    VT_TYPE = 18
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const Titan::Model::Transform *transform() const {
    return GetPointer<const Titan::Model::Transform *>(VT_TRANSFORM);
  }
  const Titan::Model::Vec3 *scalePivot() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_SCALEPIVOT);
  }
  const Titan::Model::Vec3 *rotatePivot() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_ROTATEPIVOT);
  }
  int32_t parent_idx() const {
    return GetField<int32_t>(VT_PARENT_IDX, -1);
  }
  int32_t rig_idx() const {
    return GetField<int32_t>(VT_RIG_IDX, -1);
  }
  const ::flatbuffers::String *effect_node() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EFFECT_NODE);
  }
  Titan::Model::NodeType type() const {
    return static_cast<Titan::Model::NodeType>(GetField<uint32_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TRANSFORM) &&
           verifier.VerifyTable(transform()) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_SCALEPIVOT, 4) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_ROTATEPIVOT, 4) &&
           VerifyField<int32_t>(verifier, VT_PARENT_IDX, 4) &&
           VerifyField<int32_t>(verifier, VT_RIG_IDX, 4) &&
           VerifyOffset(verifier, VT_EFFECT_NODE) &&
           verifier.VerifyString(effect_node()) &&
           VerifyField<uint32_t>(verifier, VT_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct TransformNodeBuilder {
  typedef TransformNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(TransformNode::VT_NAME, name);
  }
  void add_transform(::flatbuffers::Offset<Titan::Model::Transform> transform) {
    fbb_.AddOffset(TransformNode::VT_TRANSFORM, transform);
  }
  void add_scalePivot(const Titan::Model::Vec3 *scalePivot) {
    fbb_.AddStruct(TransformNode::VT_SCALEPIVOT, scalePivot);
  }
  void add_rotatePivot(const Titan::Model::Vec3 *rotatePivot) {
    fbb_.AddStruct(TransformNode::VT_ROTATEPIVOT, rotatePivot);
  }
  void add_parent_idx(int32_t parent_idx) {
    fbb_.AddElement<int32_t>(TransformNode::VT_PARENT_IDX, parent_idx, -1);
  }
  void add_rig_idx(int32_t rig_idx) {
    fbb_.AddElement<int32_t>(TransformNode::VT_RIG_IDX, rig_idx, -1);
  }
  void add_effect_node(::flatbuffers::Offset<::flatbuffers::String> effect_node) {
    fbb_.AddOffset(TransformNode::VT_EFFECT_NODE, effect_node);
  }
  void add_type(Titan::Model::NodeType type) {
    fbb_.AddElement<uint32_t>(TransformNode::VT_TYPE, static_cast<uint32_t>(type), 0);
  }
  explicit TransformNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransformNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransformNode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TransformNode> CreateTransformNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<Titan::Model::Transform> transform = 0,
    const Titan::Model::Vec3 *scalePivot = nullptr,
    const Titan::Model::Vec3 *rotatePivot = nullptr,
    int32_t parent_idx = -1,
    int32_t rig_idx = -1,
    ::flatbuffers::Offset<::flatbuffers::String> effect_node = 0,
    Titan::Model::NodeType type = Titan::Model::NodeType_Default) {
  TransformNodeBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_effect_node(effect_node);
  builder_.add_rig_idx(rig_idx);
  builder_.add_parent_idx(parent_idx);
  builder_.add_rotatePivot(rotatePivot);
  builder_.add_scalePivot(scalePivot);
  builder_.add_transform(transform);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TransformNode> CreateTransformNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<Titan::Model::Transform> transform = 0,
    const Titan::Model::Vec3 *scalePivot = nullptr,
    const Titan::Model::Vec3 *rotatePivot = nullptr,
    int32_t parent_idx = -1,
    int32_t rig_idx = -1,
    const char *effect_node = nullptr,
    Titan::Model::NodeType type = Titan::Model::NodeType_Default) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto effect_node__ = effect_node ? _fbb.CreateString(effect_node) : 0;
  return Titan::Model::CreateTransformNode(
      _fbb,
      name__,
      transform,
      scalePivot,
      rotatePivot,
      parent_idx,
      rig_idx,
      effect_node__,
      type);
}

struct IKControl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IKControlBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IK_NAME = 4,
    VT_IK_CHAIN_START = 6,
    VT_IK_CHAIN_END = 8,
    VT_IK_TYPE = 10,
    VT_RES_4 = 12,
    VT_IK_POS = 14,
    VT_IK_ROT = 16
  };
  const ::flatbuffers::String *ik_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IK_NAME);
  }
  const ::flatbuffers::String *ik_chain_start() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IK_CHAIN_START);
  }
  const ::flatbuffers::String *ik_chain_end() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IK_CHAIN_END);
  }
  const ::flatbuffers::String *ik_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IK_TYPE);
  }
  uint32_t res_4() const {
    return GetField<uint32_t>(VT_RES_4, 0);
  }
  const Titan::Model::Vec3 *ik_pos() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_IK_POS);
  }
  const Titan::Model::Vec4 *ik_rot() const {
    return GetStruct<const Titan::Model::Vec4 *>(VT_IK_ROT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IK_NAME) &&
           verifier.VerifyString(ik_name()) &&
           VerifyOffset(verifier, VT_IK_CHAIN_START) &&
           verifier.VerifyString(ik_chain_start()) &&
           VerifyOffset(verifier, VT_IK_CHAIN_END) &&
           verifier.VerifyString(ik_chain_end()) &&
           VerifyOffset(verifier, VT_IK_TYPE) &&
           verifier.VerifyString(ik_type()) &&
           VerifyField<uint32_t>(verifier, VT_RES_4, 4) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_IK_POS, 4) &&
           VerifyField<Titan::Model::Vec4>(verifier, VT_IK_ROT, 4) &&
           verifier.EndTable();
  }
};

struct IKControlBuilder {
  typedef IKControl Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ik_name(::flatbuffers::Offset<::flatbuffers::String> ik_name) {
    fbb_.AddOffset(IKControl::VT_IK_NAME, ik_name);
  }
  void add_ik_chain_start(::flatbuffers::Offset<::flatbuffers::String> ik_chain_start) {
    fbb_.AddOffset(IKControl::VT_IK_CHAIN_START, ik_chain_start);
  }
  void add_ik_chain_end(::flatbuffers::Offset<::flatbuffers::String> ik_chain_end) {
    fbb_.AddOffset(IKControl::VT_IK_CHAIN_END, ik_chain_end);
  }
  void add_ik_type(::flatbuffers::Offset<::flatbuffers::String> ik_type) {
    fbb_.AddOffset(IKControl::VT_IK_TYPE, ik_type);
  }
  void add_res_4(uint32_t res_4) {
    fbb_.AddElement<uint32_t>(IKControl::VT_RES_4, res_4, 0);
  }
  void add_ik_pos(const Titan::Model::Vec3 *ik_pos) {
    fbb_.AddStruct(IKControl::VT_IK_POS, ik_pos);
  }
  void add_ik_rot(const Titan::Model::Vec4 *ik_rot) {
    fbb_.AddStruct(IKControl::VT_IK_ROT, ik_rot);
  }
  explicit IKControlBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IKControl> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IKControl>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IKControl> CreateIKControl(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ik_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ik_chain_start = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ik_chain_end = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ik_type = 0,
    uint32_t res_4 = 0,
    const Titan::Model::Vec3 *ik_pos = nullptr,
    const Titan::Model::Vec4 *ik_rot = nullptr) {
  IKControlBuilder builder_(_fbb);
  builder_.add_ik_rot(ik_rot);
  builder_.add_ik_pos(ik_pos);
  builder_.add_res_4(res_4);
  builder_.add_ik_type(ik_type);
  builder_.add_ik_chain_end(ik_chain_end);
  builder_.add_ik_chain_start(ik_chain_start);
  builder_.add_ik_name(ik_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IKControl> CreateIKControlDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ik_name = nullptr,
    const char *ik_chain_start = nullptr,
    const char *ik_chain_end = nullptr,
    const char *ik_type = nullptr,
    uint32_t res_4 = 0,
    const Titan::Model::Vec3 *ik_pos = nullptr,
    const Titan::Model::Vec4 *ik_rot = nullptr) {
  auto ik_name__ = ik_name ? _fbb.CreateString(ik_name) : 0;
  auto ik_chain_start__ = ik_chain_start ? _fbb.CreateString(ik_chain_start) : 0;
  auto ik_chain_end__ = ik_chain_end ? _fbb.CreateString(ik_chain_end) : 0;
  auto ik_type__ = ik_type ? _fbb.CreateString(ik_type) : 0;
  return Titan::Model::CreateIKControl(
      _fbb,
      ik_name__,
      ik_chain_start__,
      ik_chain_end__,
      ik_type__,
      res_4,
      ik_pos,
      ik_rot);
}

struct BoneMatrix FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoneMatrixBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_W = 10
  };
  const Titan::Model::Vec3 *x() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_X);
  }
  const Titan::Model::Vec3 *y() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_Y);
  }
  const Titan::Model::Vec3 *z() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_Z);
  }
  const Titan::Model::Vec3 *w() const {
    return GetStruct<const Titan::Model::Vec3 *>(VT_W);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_X, 4) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_Y, 4) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_Z, 4) &&
           VerifyField<Titan::Model::Vec3>(verifier, VT_W, 4) &&
           verifier.EndTable();
  }
};

struct BoneMatrixBuilder {
  typedef BoneMatrix Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const Titan::Model::Vec3 *x) {
    fbb_.AddStruct(BoneMatrix::VT_X, x);
  }
  void add_y(const Titan::Model::Vec3 *y) {
    fbb_.AddStruct(BoneMatrix::VT_Y, y);
  }
  void add_z(const Titan::Model::Vec3 *z) {
    fbb_.AddStruct(BoneMatrix::VT_Z, z);
  }
  void add_w(const Titan::Model::Vec3 *w) {
    fbb_.AddStruct(BoneMatrix::VT_W, w);
  }
  explicit BoneMatrixBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoneMatrix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoneMatrix>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoneMatrix> CreateBoneMatrix(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Titan::Model::Vec3 *x = nullptr,
    const Titan::Model::Vec3 *y = nullptr,
    const Titan::Model::Vec3 *z = nullptr,
    const Titan::Model::Vec3 *w = nullptr) {
  BoneMatrixBuilder builder_(_fbb);
  builder_.add_w(w);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Bone FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoneBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INHERIT_POSITION = 4,
    VT_UNK_BOOL_2 = 6,
    VT_MATRIX = 8
  };
  uint8_t inherit_position() const {
    return GetField<uint8_t>(VT_INHERIT_POSITION, 0);
  }
  uint8_t unk_bool_2() const {
    return GetField<uint8_t>(VT_UNK_BOOL_2, 0);
  }
  const Titan::Model::BoneMatrix *matrix() const {
    return GetPointer<const Titan::Model::BoneMatrix *>(VT_MATRIX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INHERIT_POSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_UNK_BOOL_2, 1) &&
           VerifyOffset(verifier, VT_MATRIX) &&
           verifier.VerifyTable(matrix()) &&
           verifier.EndTable();
  }
};

struct BoneBuilder {
  typedef Bone Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inherit_position(uint8_t inherit_position) {
    fbb_.AddElement<uint8_t>(Bone::VT_INHERIT_POSITION, inherit_position, 0);
  }
  void add_unk_bool_2(uint8_t unk_bool_2) {
    fbb_.AddElement<uint8_t>(Bone::VT_UNK_BOOL_2, unk_bool_2, 0);
  }
  void add_matrix(::flatbuffers::Offset<Titan::Model::BoneMatrix> matrix) {
    fbb_.AddOffset(Bone::VT_MATRIX, matrix);
  }
  explicit BoneBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Bone> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Bone>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Bone> CreateBone(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t inherit_position = 0,
    uint8_t unk_bool_2 = 0,
    ::flatbuffers::Offset<Titan::Model::BoneMatrix> matrix = 0) {
  BoneBuilder builder_(_fbb);
  builder_.add_matrix(matrix);
  builder_.add_unk_bool_2(unk_bool_2);
  builder_.add_inherit_position(inherit_position);
  return builder_.Finish();
}

struct TRSKL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRSKLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RES_0 = 4,
    VT_TRANSFORM_NODES = 6,
    VT_BONES = 8,
    VT_IKS = 10,
    VT_RIG_OFFSET = 12
  };
  uint32_t res_0() const {
    return GetField<uint32_t>(VT_RES_0, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::TransformNode>> *transform_nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::TransformNode>> *>(VT_TRANSFORM_NODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Bone>> *bones() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Bone>> *>(VT_BONES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::IKControl>> *iks() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::IKControl>> *>(VT_IKS);
  }
  uint32_t rig_offset() const {
    return GetField<uint32_t>(VT_RIG_OFFSET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RES_0, 4) &&
           VerifyOffset(verifier, VT_TRANSFORM_NODES) &&
           verifier.VerifyVector(transform_nodes()) &&
           verifier.VerifyVectorOfTables(transform_nodes()) &&
           VerifyOffset(verifier, VT_BONES) &&
           verifier.VerifyVector(bones()) &&
           verifier.VerifyVectorOfTables(bones()) &&
           VerifyOffset(verifier, VT_IKS) &&
           verifier.VerifyVector(iks()) &&
           verifier.VerifyVectorOfTables(iks()) &&
           VerifyField<uint32_t>(verifier, VT_RIG_OFFSET, 4) &&
           verifier.EndTable();
  }
};

struct TRSKLBuilder {
  typedef TRSKL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_res_0(uint32_t res_0) {
    fbb_.AddElement<uint32_t>(TRSKL::VT_RES_0, res_0, 0);
  }
  void add_transform_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::TransformNode>>> transform_nodes) {
    fbb_.AddOffset(TRSKL::VT_TRANSFORM_NODES, transform_nodes);
  }
  void add_bones(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Bone>>> bones) {
    fbb_.AddOffset(TRSKL::VT_BONES, bones);
  }
  void add_iks(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::IKControl>>> iks) {
    fbb_.AddOffset(TRSKL::VT_IKS, iks);
  }
  void add_rig_offset(uint32_t rig_offset) {
    fbb_.AddElement<uint32_t>(TRSKL::VT_RIG_OFFSET, rig_offset, 0);
  }
  explicit TRSKLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TRSKL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TRSKL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TRSKL> CreateTRSKL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t res_0 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::TransformNode>>> transform_nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Bone>>> bones = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::IKControl>>> iks = 0,
    uint32_t rig_offset = 0) {
  TRSKLBuilder builder_(_fbb);
  builder_.add_rig_offset(rig_offset);
  builder_.add_iks(iks);
  builder_.add_bones(bones);
  builder_.add_transform_nodes(transform_nodes);
  builder_.add_res_0(res_0);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TRSKL> CreateTRSKLDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t res_0 = 0,
    const std::vector<::flatbuffers::Offset<Titan::Model::TransformNode>> *transform_nodes = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::Bone>> *bones = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::IKControl>> *iks = nullptr,
    uint32_t rig_offset = 0) {
  auto transform_nodes__ = transform_nodes ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::TransformNode>>(*transform_nodes) : 0;
  auto bones__ = bones ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Bone>>(*bones) : 0;
  auto iks__ = iks ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::IKControl>>(*iks) : 0;
  return Titan::Model::CreateTRSKL(
      _fbb,
      res_0,
      transform_nodes__,
      bones__,
      iks__,
      rig_offset);
}

inline const Titan::Model::TRSKL *GetTRSKL(const void *buf) {
  return ::flatbuffers::GetRoot<Titan::Model::TRSKL>(buf);
}

inline const Titan::Model::TRSKL *GetSizePrefixedTRSKL(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Titan::Model::TRSKL>(buf);
}

inline bool VerifyTRSKLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Titan::Model::TRSKL>(nullptr);
}

inline bool VerifySizePrefixedTRSKLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Titan::Model::TRSKL>(nullptr);
}

inline const char *TRSKLExtension() {
  return "trskl";
}

inline void FinishTRSKLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRSKL> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTRSKLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRSKL> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Model
}  // namespace Titan

#endif  // FLATBUFFERS_GENERATED_TRSKL_TITAN_MODEL_H_
