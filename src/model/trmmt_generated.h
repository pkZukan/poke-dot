// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRMMT_TITAN_MODEL_H_
#define FLATBUFFERS_GENERATED_TRMMT_TITAN_MODEL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Titan {
namespace Model {

struct MaterialSwitches;
struct MaterialSwitchesBuilder;

struct MaterialMapper;
struct MaterialMapperBuilder;

struct EmbeddedTRACM;
struct EmbeddedTRACMBuilder;

struct MaterialProperties;
struct MaterialPropertiesBuilder;

struct MMT;
struct MMTBuilder;

struct TRMMT;
struct TRMMTBuilder;

struct MaterialSwitches FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaterialSwitchesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL_NAME = 4,
    VT_MATERIAL_FLAG = 6
  };
  const ::flatbuffers::String *material_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATERIAL_NAME);
  }
  uint8_t material_flag() const {
    return GetField<uint8_t>(VT_MATERIAL_FLAG, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MATERIAL_NAME) &&
           verifier.VerifyString(material_name()) &&
           VerifyField<uint8_t>(verifier, VT_MATERIAL_FLAG, 1) &&
           verifier.EndTable();
  }
};

struct MaterialSwitchesBuilder {
  typedef MaterialSwitches Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_material_name(::flatbuffers::Offset<::flatbuffers::String> material_name) {
    fbb_.AddOffset(MaterialSwitches::VT_MATERIAL_NAME, material_name);
  }
  void add_material_flag(uint8_t material_flag) {
    fbb_.AddElement<uint8_t>(MaterialSwitches::VT_MATERIAL_FLAG, material_flag, 0);
  }
  explicit MaterialSwitchesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaterialSwitches> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaterialSwitches>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MaterialSwitches> CreateMaterialSwitches(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> material_name = 0,
    uint8_t material_flag = 0) {
  MaterialSwitchesBuilder builder_(_fbb);
  builder_.add_material_name(material_name);
  builder_.add_material_flag(material_flag);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MaterialSwitches> CreateMaterialSwitchesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *material_name = nullptr,
    uint8_t material_flag = 0) {
  auto material_name__ = material_name ? _fbb.CreateString(material_name) : 0;
  return Titan::Model::CreateMaterialSwitches(
      _fbb,
      material_name__,
      material_flag);
}

struct MaterialMapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaterialMapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESH_NAME = 4,
    VT_MATERIAL_NAME = 6,
    VT_LAYER_NAME = 8
  };
  const ::flatbuffers::String *mesh_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESH_NAME);
  }
  const ::flatbuffers::String *material_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATERIAL_NAME);
  }
  const ::flatbuffers::String *layer_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAYER_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESH_NAME) &&
           verifier.VerifyString(mesh_name()) &&
           VerifyOffset(verifier, VT_MATERIAL_NAME) &&
           verifier.VerifyString(material_name()) &&
           VerifyOffset(verifier, VT_LAYER_NAME) &&
           verifier.VerifyString(layer_name()) &&
           verifier.EndTable();
  }
};

struct MaterialMapperBuilder {
  typedef MaterialMapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mesh_name(::flatbuffers::Offset<::flatbuffers::String> mesh_name) {
    fbb_.AddOffset(MaterialMapper::VT_MESH_NAME, mesh_name);
  }
  void add_material_name(::flatbuffers::Offset<::flatbuffers::String> material_name) {
    fbb_.AddOffset(MaterialMapper::VT_MATERIAL_NAME, material_name);
  }
  void add_layer_name(::flatbuffers::Offset<::flatbuffers::String> layer_name) {
    fbb_.AddOffset(MaterialMapper::VT_LAYER_NAME, layer_name);
  }
  explicit MaterialMapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaterialMapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaterialMapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MaterialMapper> CreateMaterialMapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> mesh_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> material_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> layer_name = 0) {
  MaterialMapperBuilder builder_(_fbb);
  builder_.add_layer_name(layer_name);
  builder_.add_material_name(material_name);
  builder_.add_mesh_name(mesh_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MaterialMapper> CreateMaterialMapperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *mesh_name = nullptr,
    const char *material_name = nullptr,
    const char *layer_name = nullptr) {
  auto mesh_name__ = mesh_name ? _fbb.CreateString(mesh_name) : 0;
  auto material_name__ = material_name ? _fbb.CreateString(material_name) : 0;
  auto layer_name__ = layer_name ? _fbb.CreateString(layer_name) : 0;
  return Titan::Model::CreateMaterialMapper(
      _fbb,
      mesh_name__,
      material_name__,
      layer_name__);
}

struct EmbeddedTRACM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmbeddedTRACMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYTEBUFFER = 4
  };
  const ::flatbuffers::Vector<uint8_t> *bytebuffer() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BYTEBUFFER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BYTEBUFFER) &&
           verifier.VerifyVector(bytebuffer()) &&
           verifier.EndTable();
  }
};

struct EmbeddedTRACMBuilder {
  typedef EmbeddedTRACM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bytebuffer(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> bytebuffer) {
    fbb_.AddOffset(EmbeddedTRACM::VT_BYTEBUFFER, bytebuffer);
  }
  explicit EmbeddedTRACMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EmbeddedTRACM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EmbeddedTRACM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EmbeddedTRACM> CreateEmbeddedTRACM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> bytebuffer = 0) {
  EmbeddedTRACMBuilder builder_(_fbb);
  builder_.add_bytebuffer(bytebuffer);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EmbeddedTRACM> CreateEmbeddedTRACMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *bytebuffer = nullptr) {
  auto bytebuffer__ = bytebuffer ? _fbb.CreateVector<uint8_t>(*bytebuffer) : 0;
  return Titan::Model::CreateEmbeddedTRACM(
      _fbb,
      bytebuffer__);
}

struct MaterialProperties FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaterialPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_MAPPERS = 6,
    VT_RES_2 = 8,
    VT_UNK_3 = 10,
    VT_TRACM = 12,
    VT_RES_5 = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialMapper>> *mappers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialMapper>> *>(VT_MAPPERS);
  }
  uint32_t res_2() const {
    return GetField<uint32_t>(VT_RES_2, 0);
  }
  uint32_t unk_3() const {
    return GetField<uint32_t>(VT_UNK_3, 0);
  }
  const Titan::Model::EmbeddedTRACM *tracm() const {
    return GetPointer<const Titan::Model::EmbeddedTRACM *>(VT_TRACM);
  }
  const ::flatbuffers::Vector<uint32_t> *res_5() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_RES_5);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_MAPPERS) &&
           verifier.VerifyVector(mappers()) &&
           verifier.VerifyVectorOfTables(mappers()) &&
           VerifyField<uint32_t>(verifier, VT_RES_2, 4) &&
           VerifyField<uint32_t>(verifier, VT_UNK_3, 4) &&
           VerifyOffset(verifier, VT_TRACM) &&
           verifier.VerifyTable(tracm()) &&
           VerifyOffset(verifier, VT_RES_5) &&
           verifier.VerifyVector(res_5()) &&
           verifier.EndTable();
  }
};

struct MaterialPropertiesBuilder {
  typedef MaterialProperties Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(MaterialProperties::VT_NAME, name);
  }
  void add_mappers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialMapper>>> mappers) {
    fbb_.AddOffset(MaterialProperties::VT_MAPPERS, mappers);
  }
  void add_res_2(uint32_t res_2) {
    fbb_.AddElement<uint32_t>(MaterialProperties::VT_RES_2, res_2, 0);
  }
  void add_unk_3(uint32_t unk_3) {
    fbb_.AddElement<uint32_t>(MaterialProperties::VT_UNK_3, unk_3, 0);
  }
  void add_tracm(::flatbuffers::Offset<Titan::Model::EmbeddedTRACM> tracm) {
    fbb_.AddOffset(MaterialProperties::VT_TRACM, tracm);
  }
  void add_res_5(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> res_5) {
    fbb_.AddOffset(MaterialProperties::VT_RES_5, res_5);
  }
  explicit MaterialPropertiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaterialProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaterialProperties>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MaterialProperties> CreateMaterialProperties(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialMapper>>> mappers = 0,
    uint32_t res_2 = 0,
    uint32_t unk_3 = 0,
    ::flatbuffers::Offset<Titan::Model::EmbeddedTRACM> tracm = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> res_5 = 0) {
  MaterialPropertiesBuilder builder_(_fbb);
  builder_.add_res_5(res_5);
  builder_.add_tracm(tracm);
  builder_.add_unk_3(unk_3);
  builder_.add_res_2(res_2);
  builder_.add_mappers(mappers);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MaterialProperties> CreateMaterialPropertiesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::MaterialMapper>> *mappers = nullptr,
    uint32_t res_2 = 0,
    uint32_t unk_3 = 0,
    ::flatbuffers::Offset<Titan::Model::EmbeddedTRACM> tracm = 0,
    const std::vector<uint32_t> *res_5 = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto mappers__ = mappers ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MaterialMapper>>(*mappers) : 0;
  auto res_5__ = res_5 ? _fbb.CreateVector<uint32_t>(*res_5) : 0;
  return Titan::Model::CreateMaterialProperties(
      _fbb,
      name__,
      mappers__,
      res_2,
      unk_3,
      tracm,
      res_5__);
}

struct MMT FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MMTBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_MATERIAL_NAME = 6,
    VT_MATERIAL_SWITCHES = 8,
    VT_MATERIAL_PROPERTIES = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *material_name() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MATERIAL_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialSwitches>> *material_switches() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialSwitches>> *>(VT_MATERIAL_SWITCHES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialProperties>> *material_properties() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialProperties>> *>(VT_MATERIAL_PROPERTIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_MATERIAL_NAME) &&
           verifier.VerifyVector(material_name()) &&
           verifier.VerifyVectorOfStrings(material_name()) &&
           VerifyOffset(verifier, VT_MATERIAL_SWITCHES) &&
           verifier.VerifyVector(material_switches()) &&
           verifier.VerifyVectorOfTables(material_switches()) &&
           VerifyOffset(verifier, VT_MATERIAL_PROPERTIES) &&
           verifier.VerifyVector(material_properties()) &&
           verifier.VerifyVectorOfTables(material_properties()) &&
           verifier.EndTable();
  }
};

struct MMTBuilder {
  typedef MMT Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(MMT::VT_NAME, name);
  }
  void add_material_name(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> material_name) {
    fbb_.AddOffset(MMT::VT_MATERIAL_NAME, material_name);
  }
  void add_material_switches(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialSwitches>>> material_switches) {
    fbb_.AddOffset(MMT::VT_MATERIAL_SWITCHES, material_switches);
  }
  void add_material_properties(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialProperties>>> material_properties) {
    fbb_.AddOffset(MMT::VT_MATERIAL_PROPERTIES, material_properties);
  }
  explicit MMTBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MMT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MMT>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MMT> CreateMMT(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> material_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialSwitches>>> material_switches = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MaterialProperties>>> material_properties = 0) {
  MMTBuilder builder_(_fbb);
  builder_.add_material_properties(material_properties);
  builder_.add_material_switches(material_switches);
  builder_.add_material_name(material_name);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MMT> CreateMMTDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *material_name = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::MaterialSwitches>> *material_switches = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::MaterialProperties>> *material_properties = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto material_name__ = material_name ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*material_name) : 0;
  auto material_switches__ = material_switches ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MaterialSwitches>>(*material_switches) : 0;
  auto material_properties__ = material_properties ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MaterialProperties>>(*material_properties) : 0;
  return Titan::Model::CreateMMT(
      _fbb,
      name__,
      material_name__,
      material_switches__,
      material_properties__);
}

struct TRMMT FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRMMTBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RES_0 = 4,
    VT_RES_1 = 6,
    VT_MATERIAL = 8
  };
  uint32_t res_0() const {
    return GetField<uint32_t>(VT_RES_0, 0);
  }
  uint32_t res_1() const {
    return GetField<uint32_t>(VT_RES_1, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MMT>> *material() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MMT>> *>(VT_MATERIAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RES_0, 4) &&
           VerifyField<uint32_t>(verifier, VT_RES_1, 4) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyVector(material()) &&
           verifier.VerifyVectorOfTables(material()) &&
           verifier.EndTable();
  }
};

struct TRMMTBuilder {
  typedef TRMMT Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_res_0(uint32_t res_0) {
    fbb_.AddElement<uint32_t>(TRMMT::VT_RES_0, res_0, 0);
  }
  void add_res_1(uint32_t res_1) {
    fbb_.AddElement<uint32_t>(TRMMT::VT_RES_1, res_1, 0);
  }
  void add_material(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MMT>>> material) {
    fbb_.AddOffset(TRMMT::VT_MATERIAL, material);
  }
  explicit TRMMTBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TRMMT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TRMMT>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TRMMT> CreateTRMMT(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t res_0 = 0,
    uint32_t res_1 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::MMT>>> material = 0) {
  TRMMTBuilder builder_(_fbb);
  builder_.add_material(material);
  builder_.add_res_1(res_1);
  builder_.add_res_0(res_0);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TRMMT> CreateTRMMTDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t res_0 = 0,
    uint32_t res_1 = 0,
    const std::vector<::flatbuffers::Offset<Titan::Model::MMT>> *material = nullptr) {
  auto material__ = material ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::MMT>>(*material) : 0;
  return Titan::Model::CreateTRMMT(
      _fbb,
      res_0,
      res_1,
      material__);
}

inline const Titan::Model::TRMMT *GetTRMMT(const void *buf) {
  return ::flatbuffers::GetRoot<Titan::Model::TRMMT>(buf);
}

inline const Titan::Model::TRMMT *GetSizePrefixedTRMMT(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Titan::Model::TRMMT>(buf);
}

inline bool VerifyTRMMTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Titan::Model::TRMMT>(nullptr);
}

inline bool VerifySizePrefixedTRMMTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Titan::Model::TRMMT>(nullptr);
}

inline const char *TRMMTExtension() {
  return "trmmt";
}

inline void FinishTRMMTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRMMT> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTRMMTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRMMT> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Model
}  // namespace Titan

#endif  // FLATBUFFERS_GENERATED_TRMMT_TITAN_MODEL_H_
