// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRMTR_TITAN_MODEL_H_
#define FLATBUFFERS_GENERATED_TRMTR_TITAN_MODEL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Titan {
namespace Model {

struct RGBA;

struct SamplerState;
struct SamplerStateBuilder;

struct Float4Parameter;
struct Float4ParameterBuilder;

struct FloatParameter;
struct FloatParameterBuilder;

struct IntParameter;
struct IntParameterBuilder;

struct StringParameter;
struct StringParameterBuilder;

struct Shader;
struct ShaderBuilder;

struct Texture;
struct TextureBuilder;

struct Byte_Extra;
struct Byte_ExtraBuilder;

struct Int_Extra;
struct Int_ExtraBuilder;

struct Material;
struct MaterialBuilder;

struct TRMTR;
struct TRMTRBuilder;

enum UVWrapMode : uint32_t {
  UVWrapMode_WRAP = 0,
  UVWrapMode_CLAMP = 1,
  UVWrapMode_MIRROR = 6,
  UVWrapMode_MIRROR_ONCE = 7,
  UVWrapMode_MIN = UVWrapMode_WRAP,
  UVWrapMode_MAX = UVWrapMode_MIRROR_ONCE
};

inline const UVWrapMode (&EnumValuesUVWrapMode())[4] {
  static const UVWrapMode values[] = {
    UVWrapMode_WRAP,
    UVWrapMode_CLAMP,
    UVWrapMode_MIRROR,
    UVWrapMode_MIRROR_ONCE
  };
  return values;
}

inline const char * const *EnumNamesUVWrapMode() {
  static const char * const names[9] = {
    "WRAP",
    "CLAMP",
    "",
    "",
    "",
    "",
    "MIRROR",
    "MIRROR_ONCE",
    nullptr
  };
  return names;
}

inline const char *EnumNameUVWrapMode(UVWrapMode e) {
  if (::flatbuffers::IsOutRange(e, UVWrapMode_WRAP, UVWrapMode_MIRROR_ONCE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUVWrapMode()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RGBA FLATBUFFERS_FINAL_CLASS {
 private:
  float r_;
  float g_;
  float b_;
  float a_;

 public:
  RGBA()
      : r_(0),
        g_(0),
        b_(0),
        a_(0) {
  }
  RGBA(float _r, float _g, float _b, float _a)
      : r_(::flatbuffers::EndianScalar(_r)),
        g_(::flatbuffers::EndianScalar(_g)),
        b_(::flatbuffers::EndianScalar(_b)),
        a_(::flatbuffers::EndianScalar(_a)) {
  }
  float r() const {
    return ::flatbuffers::EndianScalar(r_);
  }
  float g() const {
    return ::flatbuffers::EndianScalar(g_);
  }
  float b() const {
    return ::flatbuffers::EndianScalar(b_);
  }
  float a() const {
    return ::flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(RGBA, 16);

struct SamplerState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SamplerStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SAMPLERSTATE_0 = 4,
    VT_SAMPLERSTATE_1 = 6,
    VT_SAMPLERSTATE_2 = 8,
    VT_SAMPLERSTATE_3 = 10,
    VT_SAMPLERSTATE_4 = 12,
    VT_SAMPLERSTATE_5 = 14,
    VT_SAMPLERSTATE_6 = 16,
    VT_SAMPLERSTATE_7 = 18,
    VT_SAMPLERSTATE_8 = 20,
    VT_REPEAT_U = 22,
    VT_REPEAT_V = 24,
    VT_REPEAT_W = 26,
    VT_BORDER_COLOR = 28
  };
  uint32_t SamplerState_0() const {
    return GetField<uint32_t>(VT_SAMPLERSTATE_0, 0);
  }
  uint32_t SamplerState_1() const {
    return GetField<uint32_t>(VT_SAMPLERSTATE_1, 0);
  }
  uint32_t SamplerState_2() const {
    return GetField<uint32_t>(VT_SAMPLERSTATE_2, 0);
  }
  uint32_t SamplerState_3() const {
    return GetField<uint32_t>(VT_SAMPLERSTATE_3, 0);
  }
  uint32_t SamplerState_4() const {
    return GetField<uint32_t>(VT_SAMPLERSTATE_4, 0);
  }
  uint32_t SamplerState_5() const {
    return GetField<uint32_t>(VT_SAMPLERSTATE_5, 0);
  }
  uint32_t SamplerState_6() const {
    return GetField<uint32_t>(VT_SAMPLERSTATE_6, 0);
  }
  uint32_t SamplerState_7() const {
    return GetField<uint32_t>(VT_SAMPLERSTATE_7, 0);
  }
  uint32_t SamplerState_8() const {
    return GetField<uint32_t>(VT_SAMPLERSTATE_8, 0);
  }
  Titan::Model::UVWrapMode repeat_u() const {
    return static_cast<Titan::Model::UVWrapMode>(GetField<uint32_t>(VT_REPEAT_U, 0));
  }
  Titan::Model::UVWrapMode repeat_v() const {
    return static_cast<Titan::Model::UVWrapMode>(GetField<uint32_t>(VT_REPEAT_V, 0));
  }
  Titan::Model::UVWrapMode repeat_w() const {
    return static_cast<Titan::Model::UVWrapMode>(GetField<uint32_t>(VT_REPEAT_W, 0));
  }
  const Titan::Model::RGBA *border_color() const {
    return GetStruct<const Titan::Model::RGBA *>(VT_BORDER_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLERSTATE_0, 4) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLERSTATE_1, 4) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLERSTATE_2, 4) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLERSTATE_3, 4) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLERSTATE_4, 4) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLERSTATE_5, 4) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLERSTATE_6, 4) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLERSTATE_7, 4) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLERSTATE_8, 4) &&
           VerifyField<uint32_t>(verifier, VT_REPEAT_U, 4) &&
           VerifyField<uint32_t>(verifier, VT_REPEAT_V, 4) &&
           VerifyField<uint32_t>(verifier, VT_REPEAT_W, 4) &&
           VerifyField<Titan::Model::RGBA>(verifier, VT_BORDER_COLOR, 4) &&
           verifier.EndTable();
  }
};

struct SamplerStateBuilder {
  typedef SamplerState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SamplerState_0(uint32_t SamplerState_0) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_SAMPLERSTATE_0, SamplerState_0, 0);
  }
  void add_SamplerState_1(uint32_t SamplerState_1) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_SAMPLERSTATE_1, SamplerState_1, 0);
  }
  void add_SamplerState_2(uint32_t SamplerState_2) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_SAMPLERSTATE_2, SamplerState_2, 0);
  }
  void add_SamplerState_3(uint32_t SamplerState_3) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_SAMPLERSTATE_3, SamplerState_3, 0);
  }
  void add_SamplerState_4(uint32_t SamplerState_4) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_SAMPLERSTATE_4, SamplerState_4, 0);
  }
  void add_SamplerState_5(uint32_t SamplerState_5) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_SAMPLERSTATE_5, SamplerState_5, 0);
  }
  void add_SamplerState_6(uint32_t SamplerState_6) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_SAMPLERSTATE_6, SamplerState_6, 0);
  }
  void add_SamplerState_7(uint32_t SamplerState_7) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_SAMPLERSTATE_7, SamplerState_7, 0);
  }
  void add_SamplerState_8(uint32_t SamplerState_8) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_SAMPLERSTATE_8, SamplerState_8, 0);
  }
  void add_repeat_u(Titan::Model::UVWrapMode repeat_u) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_REPEAT_U, static_cast<uint32_t>(repeat_u), 0);
  }
  void add_repeat_v(Titan::Model::UVWrapMode repeat_v) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_REPEAT_V, static_cast<uint32_t>(repeat_v), 0);
  }
  void add_repeat_w(Titan::Model::UVWrapMode repeat_w) {
    fbb_.AddElement<uint32_t>(SamplerState::VT_REPEAT_W, static_cast<uint32_t>(repeat_w), 0);
  }
  void add_border_color(const Titan::Model::RGBA *border_color) {
    fbb_.AddStruct(SamplerState::VT_BORDER_COLOR, border_color);
  }
  explicit SamplerStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SamplerState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SamplerState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SamplerState> CreateSamplerState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t SamplerState_0 = 0,
    uint32_t SamplerState_1 = 0,
    uint32_t SamplerState_2 = 0,
    uint32_t SamplerState_3 = 0,
    uint32_t SamplerState_4 = 0,
    uint32_t SamplerState_5 = 0,
    uint32_t SamplerState_6 = 0,
    uint32_t SamplerState_7 = 0,
    uint32_t SamplerState_8 = 0,
    Titan::Model::UVWrapMode repeat_u = Titan::Model::UVWrapMode_WRAP,
    Titan::Model::UVWrapMode repeat_v = Titan::Model::UVWrapMode_WRAP,
    Titan::Model::UVWrapMode repeat_w = Titan::Model::UVWrapMode_WRAP,
    const Titan::Model::RGBA *border_color = nullptr) {
  SamplerStateBuilder builder_(_fbb);
  builder_.add_border_color(border_color);
  builder_.add_repeat_w(repeat_w);
  builder_.add_repeat_v(repeat_v);
  builder_.add_repeat_u(repeat_u);
  builder_.add_SamplerState_8(SamplerState_8);
  builder_.add_SamplerState_7(SamplerState_7);
  builder_.add_SamplerState_6(SamplerState_6);
  builder_.add_SamplerState_5(SamplerState_5);
  builder_.add_SamplerState_4(SamplerState_4);
  builder_.add_SamplerState_3(SamplerState_3);
  builder_.add_SamplerState_2(SamplerState_2);
  builder_.add_SamplerState_1(SamplerState_1);
  builder_.add_SamplerState_0(SamplerState_0);
  return builder_.Finish();
}

struct Float4Parameter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Float4ParameterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR_NAME = 4,
    VT_COLOR_VALUE = 6
  };
  const ::flatbuffers::String *color_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLOR_NAME);
  }
  const Titan::Model::RGBA *color_value() const {
    return GetStruct<const Titan::Model::RGBA *>(VT_COLOR_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR_NAME) &&
           verifier.VerifyString(color_name()) &&
           VerifyField<Titan::Model::RGBA>(verifier, VT_COLOR_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct Float4ParameterBuilder {
  typedef Float4Parameter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color_name(::flatbuffers::Offset<::flatbuffers::String> color_name) {
    fbb_.AddOffset(Float4Parameter::VT_COLOR_NAME, color_name);
  }
  void add_color_value(const Titan::Model::RGBA *color_value) {
    fbb_.AddStruct(Float4Parameter::VT_COLOR_VALUE, color_value);
  }
  explicit Float4ParameterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Float4Parameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Float4Parameter>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Float4Parameter> CreateFloat4Parameter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> color_name = 0,
    const Titan::Model::RGBA *color_value = nullptr) {
  Float4ParameterBuilder builder_(_fbb);
  builder_.add_color_value(color_value);
  builder_.add_color_name(color_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Float4Parameter> CreateFloat4ParameterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *color_name = nullptr,
    const Titan::Model::RGBA *color_value = nullptr) {
  auto color_name__ = color_name ? _fbb.CreateString(color_name) : 0;
  return Titan::Model::CreateFloat4Parameter(
      _fbb,
      color_name__,
      color_value);
}

struct FloatParameter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatParameterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOAT_NAME = 4,
    VT_FLOAT_VALUE = 6
  };
  const ::flatbuffers::String *float_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FLOAT_NAME);
  }
  float float_value() const {
    return GetField<float>(VT_FLOAT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FLOAT_NAME) &&
           verifier.VerifyString(float_name()) &&
           VerifyField<float>(verifier, VT_FLOAT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct FloatParameterBuilder {
  typedef FloatParameter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_float_name(::flatbuffers::Offset<::flatbuffers::String> float_name) {
    fbb_.AddOffset(FloatParameter::VT_FLOAT_NAME, float_name);
  }
  void add_float_value(float float_value) {
    fbb_.AddElement<float>(FloatParameter::VT_FLOAT_VALUE, float_value, 0.0f);
  }
  explicit FloatParameterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatParameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatParameter>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatParameter> CreateFloatParameter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> float_name = 0,
    float float_value = 0.0f) {
  FloatParameterBuilder builder_(_fbb);
  builder_.add_float_value(float_value);
  builder_.add_float_name(float_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FloatParameter> CreateFloatParameterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *float_name = nullptr,
    float float_value = 0.0f) {
  auto float_name__ = float_name ? _fbb.CreateString(float_name) : 0;
  return Titan::Model::CreateFloatParameter(
      _fbb,
      float_name__,
      float_value);
}

struct IntParameter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntParameterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INT_NAME = 4,
    VT_INT_VALUE = 6
  };
  const ::flatbuffers::String *int_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INT_NAME);
  }
  int32_t int_value() const {
    return GetField<int32_t>(VT_INT_VALUE, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INT_NAME) &&
           verifier.VerifyString(int_name()) &&
           VerifyField<int32_t>(verifier, VT_INT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct IntParameterBuilder {
  typedef IntParameter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_int_name(::flatbuffers::Offset<::flatbuffers::String> int_name) {
    fbb_.AddOffset(IntParameter::VT_INT_NAME, int_name);
  }
  void add_int_value(int32_t int_value) {
    fbb_.AddElement<int32_t>(IntParameter::VT_INT_VALUE, int_value, -1);
  }
  explicit IntParameterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntParameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntParameter>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntParameter> CreateIntParameter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> int_name = 0,
    int32_t int_value = -1) {
  IntParameterBuilder builder_(_fbb);
  builder_.add_int_value(int_value);
  builder_.add_int_name(int_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntParameter> CreateIntParameterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *int_name = nullptr,
    int32_t int_value = -1) {
  auto int_name__ = int_name ? _fbb.CreateString(int_name) : 0;
  return Titan::Model::CreateIntParameter(
      _fbb,
      int_name__,
      int_value);
}

struct StringParameter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringParameterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRING_NAME = 4,
    VT_STRING_VALUE = 6
  };
  const ::flatbuffers::String *string_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STRING_NAME);
  }
  const ::flatbuffers::String *string_value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STRING_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRING_NAME) &&
           verifier.VerifyString(string_name()) &&
           VerifyOffset(verifier, VT_STRING_VALUE) &&
           verifier.VerifyString(string_value()) &&
           verifier.EndTable();
  }
};

struct StringParameterBuilder {
  typedef StringParameter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_string_name(::flatbuffers::Offset<::flatbuffers::String> string_name) {
    fbb_.AddOffset(StringParameter::VT_STRING_NAME, string_name);
  }
  void add_string_value(::flatbuffers::Offset<::flatbuffers::String> string_value) {
    fbb_.AddOffset(StringParameter::VT_STRING_VALUE, string_value);
  }
  explicit StringParameterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringParameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringParameter>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringParameter> CreateStringParameter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> string_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> string_value = 0) {
  StringParameterBuilder builder_(_fbb);
  builder_.add_string_value(string_value);
  builder_.add_string_name(string_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StringParameter> CreateStringParameterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *string_name = nullptr,
    const char *string_value = nullptr) {
  auto string_name__ = string_name ? _fbb.CreateString(string_name) : 0;
  auto string_value__ = string_value ? _fbb.CreateString(string_value) : 0;
  return Titan::Model::CreateStringParameter(
      _fbb,
      string_name__,
      string_value__);
}

struct Shader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHADER_NAME = 4,
    VT_SHADER_VALUES = 6
  };
  const ::flatbuffers::String *shader_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHADER_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::StringParameter>> *shader_values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::StringParameter>> *>(VT_SHADER_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHADER_NAME) &&
           verifier.VerifyString(shader_name()) &&
           VerifyOffset(verifier, VT_SHADER_VALUES) &&
           verifier.VerifyVector(shader_values()) &&
           verifier.VerifyVectorOfTables(shader_values()) &&
           verifier.EndTable();
  }
};

struct ShaderBuilder {
  typedef Shader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shader_name(::flatbuffers::Offset<::flatbuffers::String> shader_name) {
    fbb_.AddOffset(Shader::VT_SHADER_NAME, shader_name);
  }
  void add_shader_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::StringParameter>>> shader_values) {
    fbb_.AddOffset(Shader::VT_SHADER_VALUES, shader_values);
  }
  explicit ShaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Shader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Shader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Shader> CreateShader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shader_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::StringParameter>>> shader_values = 0) {
  ShaderBuilder builder_(_fbb);
  builder_.add_shader_values(shader_values);
  builder_.add_shader_name(shader_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Shader> CreateShaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shader_name = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::StringParameter>> *shader_values = nullptr) {
  auto shader_name__ = shader_name ? _fbb.CreateString(shader_name) : 0;
  auto shader_values__ = shader_values ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::StringParameter>>(*shader_values) : 0;
  return Titan::Model::CreateShader(
      _fbb,
      shader_name__,
      shader_values__);
}

struct Texture FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXTURE_NAME = 4,
    VT_TEXTURE_FILE = 6,
    VT_TEXTURE_SLOT = 8
  };
  const ::flatbuffers::String *texture_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXTURE_NAME);
  }
  const ::flatbuffers::String *texture_file() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXTURE_FILE);
  }
  uint32_t texture_slot() const {
    return GetField<uint32_t>(VT_TEXTURE_SLOT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXTURE_NAME) &&
           verifier.VerifyString(texture_name()) &&
           VerifyOffset(verifier, VT_TEXTURE_FILE) &&
           verifier.VerifyString(texture_file()) &&
           VerifyField<uint32_t>(verifier, VT_TEXTURE_SLOT, 4) &&
           verifier.EndTable();
  }
};

struct TextureBuilder {
  typedef Texture Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_texture_name(::flatbuffers::Offset<::flatbuffers::String> texture_name) {
    fbb_.AddOffset(Texture::VT_TEXTURE_NAME, texture_name);
  }
  void add_texture_file(::flatbuffers::Offset<::flatbuffers::String> texture_file) {
    fbb_.AddOffset(Texture::VT_TEXTURE_FILE, texture_file);
  }
  void add_texture_slot(uint32_t texture_slot) {
    fbb_.AddElement<uint32_t>(Texture::VT_TEXTURE_SLOT, texture_slot, 0);
  }
  explicit TextureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Texture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Texture>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Texture> CreateTexture(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> texture_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> texture_file = 0,
    uint32_t texture_slot = 0) {
  TextureBuilder builder_(_fbb);
  builder_.add_texture_slot(texture_slot);
  builder_.add_texture_file(texture_file);
  builder_.add_texture_name(texture_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Texture> CreateTextureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *texture_name = nullptr,
    const char *texture_file = nullptr,
    uint32_t texture_slot = 0) {
  auto texture_name__ = texture_name ? _fbb.CreateString(texture_name) : 0;
  auto texture_file__ = texture_file ? _fbb.CreateString(texture_file) : 0;
  return Titan::Model::CreateTexture(
      _fbb,
      texture_name__,
      texture_file__,
      texture_slot);
}

struct Byte_Extra FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Byte_ExtraBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct Byte_ExtraBuilder {
  typedef Byte_Extra Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(Byte_Extra::VT_VALUE, value, -1);
  }
  explicit Byte_ExtraBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Byte_Extra> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Byte_Extra>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Byte_Extra> CreateByte_Extra(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t value = -1) {
  Byte_ExtraBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int_Extra FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int_ExtraBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RES_0 = 4,
    VT_VALUE = 6
  };
  uint32_t res_0() const {
    return GetField<uint32_t>(VT_RES_0, 0);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RES_0, 4) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct Int_ExtraBuilder {
  typedef Int_Extra Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_res_0(uint32_t res_0) {
    fbb_.AddElement<uint32_t>(Int_Extra::VT_RES_0, res_0, 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Int_Extra::VT_VALUE, value, -1);
  }
  explicit Int_ExtraBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int_Extra> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int_Extra>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int_Extra> CreateInt_Extra(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t res_0 = 0,
    int32_t value = -1) {
  Int_ExtraBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_res_0(res_0);
  return builder_.Finish();
}

struct Material FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaterialBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHADERS = 6,
    VT_TEXTURES = 8,
    VT_SAMPLERS = 10,
    VT_FLOAT_PARAMETER = 12,
    VT_UNK_5 = 14,
    VT_FLOAT4_LIGHT_PARAMETER = 16,
    VT_FLOAT4_PARAMETER = 18,
    VT_UNK_8 = 20,
    VT_INT_PARAMETER = 22,
    VT_UNK_10 = 24,
    VT_UNK_11 = 26,
    VT_UNK_12 = 28,
    VT_BYTE_EXTRA = 30,
    VT_INT_EXTRA = 32,
    VT_ALPHA_TYPE = 34
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Shader>> *shaders() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Shader>> *>(VT_SHADERS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Texture>> *textures() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Texture>> *>(VT_TEXTURES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::SamplerState>> *samplers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::SamplerState>> *>(VT_SAMPLERS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::FloatParameter>> *float_parameter() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::FloatParameter>> *>(VT_FLOAT_PARAMETER);
  }
  const ::flatbuffers::String *unk_5() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNK_5);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Float4Parameter>> *float4_light_parameter() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Float4Parameter>> *>(VT_FLOAT4_LIGHT_PARAMETER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Float4Parameter>> *float4_parameter() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Float4Parameter>> *>(VT_FLOAT4_PARAMETER);
  }
  const ::flatbuffers::String *unk_8() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNK_8);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::IntParameter>> *int_parameter() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::IntParameter>> *>(VT_INT_PARAMETER);
  }
  const ::flatbuffers::String *unk_10() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNK_10);
  }
  const ::flatbuffers::String *unk_11() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNK_11);
  }
  const ::flatbuffers::String *unk_12() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNK_12);
  }
  const Titan::Model::Byte_Extra *byte_extra() const {
    return GetPointer<const Titan::Model::Byte_Extra *>(VT_BYTE_EXTRA);
  }
  const Titan::Model::Int_Extra *int_extra() const {
    return GetPointer<const Titan::Model::Int_Extra *>(VT_INT_EXTRA);
  }
  const ::flatbuffers::String *alpha_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALPHA_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SHADERS) &&
           verifier.VerifyVector(shaders()) &&
           verifier.VerifyVectorOfTables(shaders()) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.VerifyVector(textures()) &&
           verifier.VerifyVectorOfTables(textures()) &&
           VerifyOffset(verifier, VT_SAMPLERS) &&
           verifier.VerifyVector(samplers()) &&
           verifier.VerifyVectorOfTables(samplers()) &&
           VerifyOffset(verifier, VT_FLOAT_PARAMETER) &&
           verifier.VerifyVector(float_parameter()) &&
           verifier.VerifyVectorOfTables(float_parameter()) &&
           VerifyOffset(verifier, VT_UNK_5) &&
           verifier.VerifyString(unk_5()) &&
           VerifyOffset(verifier, VT_FLOAT4_LIGHT_PARAMETER) &&
           verifier.VerifyVector(float4_light_parameter()) &&
           verifier.VerifyVectorOfTables(float4_light_parameter()) &&
           VerifyOffset(verifier, VT_FLOAT4_PARAMETER) &&
           verifier.VerifyVector(float4_parameter()) &&
           verifier.VerifyVectorOfTables(float4_parameter()) &&
           VerifyOffset(verifier, VT_UNK_8) &&
           verifier.VerifyString(unk_8()) &&
           VerifyOffset(verifier, VT_INT_PARAMETER) &&
           verifier.VerifyVector(int_parameter()) &&
           verifier.VerifyVectorOfTables(int_parameter()) &&
           VerifyOffset(verifier, VT_UNK_10) &&
           verifier.VerifyString(unk_10()) &&
           VerifyOffset(verifier, VT_UNK_11) &&
           verifier.VerifyString(unk_11()) &&
           VerifyOffset(verifier, VT_UNK_12) &&
           verifier.VerifyString(unk_12()) &&
           VerifyOffset(verifier, VT_BYTE_EXTRA) &&
           verifier.VerifyTable(byte_extra()) &&
           VerifyOffset(verifier, VT_INT_EXTRA) &&
           verifier.VerifyTable(int_extra()) &&
           VerifyOffset(verifier, VT_ALPHA_TYPE) &&
           verifier.VerifyString(alpha_type()) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  typedef Material Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Material::VT_NAME, name);
  }
  void add_shaders(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Shader>>> shaders) {
    fbb_.AddOffset(Material::VT_SHADERS, shaders);
  }
  void add_textures(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Texture>>> textures) {
    fbb_.AddOffset(Material::VT_TEXTURES, textures);
  }
  void add_samplers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::SamplerState>>> samplers) {
    fbb_.AddOffset(Material::VT_SAMPLERS, samplers);
  }
  void add_float_parameter(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::FloatParameter>>> float_parameter) {
    fbb_.AddOffset(Material::VT_FLOAT_PARAMETER, float_parameter);
  }
  void add_unk_5(::flatbuffers::Offset<::flatbuffers::String> unk_5) {
    fbb_.AddOffset(Material::VT_UNK_5, unk_5);
  }
  void add_float4_light_parameter(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Float4Parameter>>> float4_light_parameter) {
    fbb_.AddOffset(Material::VT_FLOAT4_LIGHT_PARAMETER, float4_light_parameter);
  }
  void add_float4_parameter(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Float4Parameter>>> float4_parameter) {
    fbb_.AddOffset(Material::VT_FLOAT4_PARAMETER, float4_parameter);
  }
  void add_unk_8(::flatbuffers::Offset<::flatbuffers::String> unk_8) {
    fbb_.AddOffset(Material::VT_UNK_8, unk_8);
  }
  void add_int_parameter(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::IntParameter>>> int_parameter) {
    fbb_.AddOffset(Material::VT_INT_PARAMETER, int_parameter);
  }
  void add_unk_10(::flatbuffers::Offset<::flatbuffers::String> unk_10) {
    fbb_.AddOffset(Material::VT_UNK_10, unk_10);
  }
  void add_unk_11(::flatbuffers::Offset<::flatbuffers::String> unk_11) {
    fbb_.AddOffset(Material::VT_UNK_11, unk_11);
  }
  void add_unk_12(::flatbuffers::Offset<::flatbuffers::String> unk_12) {
    fbb_.AddOffset(Material::VT_UNK_12, unk_12);
  }
  void add_byte_extra(::flatbuffers::Offset<Titan::Model::Byte_Extra> byte_extra) {
    fbb_.AddOffset(Material::VT_BYTE_EXTRA, byte_extra);
  }
  void add_int_extra(::flatbuffers::Offset<Titan::Model::Int_Extra> int_extra) {
    fbb_.AddOffset(Material::VT_INT_EXTRA, int_extra);
  }
  void add_alpha_type(::flatbuffers::Offset<::flatbuffers::String> alpha_type) {
    fbb_.AddOffset(Material::VT_ALPHA_TYPE, alpha_type);
  }
  explicit MaterialBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Material>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Material> CreateMaterial(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Shader>>> shaders = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Texture>>> textures = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::SamplerState>>> samplers = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::FloatParameter>>> float_parameter = 0,
    ::flatbuffers::Offset<::flatbuffers::String> unk_5 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Float4Parameter>>> float4_light_parameter = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Float4Parameter>>> float4_parameter = 0,
    ::flatbuffers::Offset<::flatbuffers::String> unk_8 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::IntParameter>>> int_parameter = 0,
    ::flatbuffers::Offset<::flatbuffers::String> unk_10 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> unk_11 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> unk_12 = 0,
    ::flatbuffers::Offset<Titan::Model::Byte_Extra> byte_extra = 0,
    ::flatbuffers::Offset<Titan::Model::Int_Extra> int_extra = 0,
    ::flatbuffers::Offset<::flatbuffers::String> alpha_type = 0) {
  MaterialBuilder builder_(_fbb);
  builder_.add_alpha_type(alpha_type);
  builder_.add_int_extra(int_extra);
  builder_.add_byte_extra(byte_extra);
  builder_.add_unk_12(unk_12);
  builder_.add_unk_11(unk_11);
  builder_.add_unk_10(unk_10);
  builder_.add_int_parameter(int_parameter);
  builder_.add_unk_8(unk_8);
  builder_.add_float4_parameter(float4_parameter);
  builder_.add_float4_light_parameter(float4_light_parameter);
  builder_.add_unk_5(unk_5);
  builder_.add_float_parameter(float_parameter);
  builder_.add_samplers(samplers);
  builder_.add_textures(textures);
  builder_.add_shaders(shaders);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Material> CreateMaterialDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::Shader>> *shaders = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::Texture>> *textures = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::SamplerState>> *samplers = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::FloatParameter>> *float_parameter = nullptr,
    const char *unk_5 = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::Float4Parameter>> *float4_light_parameter = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::Float4Parameter>> *float4_parameter = nullptr,
    const char *unk_8 = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Model::IntParameter>> *int_parameter = nullptr,
    const char *unk_10 = nullptr,
    const char *unk_11 = nullptr,
    const char *unk_12 = nullptr,
    ::flatbuffers::Offset<Titan::Model::Byte_Extra> byte_extra = 0,
    ::flatbuffers::Offset<Titan::Model::Int_Extra> int_extra = 0,
    const char *alpha_type = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shaders__ = shaders ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Shader>>(*shaders) : 0;
  auto textures__ = textures ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Texture>>(*textures) : 0;
  auto samplers__ = samplers ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::SamplerState>>(*samplers) : 0;
  auto float_parameter__ = float_parameter ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::FloatParameter>>(*float_parameter) : 0;
  auto unk_5__ = unk_5 ? _fbb.CreateString(unk_5) : 0;
  auto float4_light_parameter__ = float4_light_parameter ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Float4Parameter>>(*float4_light_parameter) : 0;
  auto float4_parameter__ = float4_parameter ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Float4Parameter>>(*float4_parameter) : 0;
  auto unk_8__ = unk_8 ? _fbb.CreateString(unk_8) : 0;
  auto int_parameter__ = int_parameter ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::IntParameter>>(*int_parameter) : 0;
  auto unk_10__ = unk_10 ? _fbb.CreateString(unk_10) : 0;
  auto unk_11__ = unk_11 ? _fbb.CreateString(unk_11) : 0;
  auto unk_12__ = unk_12 ? _fbb.CreateString(unk_12) : 0;
  auto alpha_type__ = alpha_type ? _fbb.CreateString(alpha_type) : 0;
  return Titan::Model::CreateMaterial(
      _fbb,
      name__,
      shaders__,
      textures__,
      samplers__,
      float_parameter__,
      unk_5__,
      float4_light_parameter__,
      float4_parameter__,
      unk_8__,
      int_parameter__,
      unk_10__,
      unk_11__,
      unk_12__,
      byte_extra,
      int_extra,
      alpha_type__);
}

struct TRMTR FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRMTRBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RES_0 = 4,
    VT_MATERIALS = 6
  };
  uint32_t res_0() const {
    return GetField<uint32_t>(VT_RES_0, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Material>> *materials() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Material>> *>(VT_MATERIALS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RES_0, 4) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           verifier.VerifyVectorOfTables(materials()) &&
           verifier.EndTable();
  }
};

struct TRMTRBuilder {
  typedef TRMTR Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_res_0(uint32_t res_0) {
    fbb_.AddElement<uint32_t>(TRMTR::VT_RES_0, res_0, 0);
  }
  void add_materials(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Material>>> materials) {
    fbb_.AddOffset(TRMTR::VT_MATERIALS, materials);
  }
  explicit TRMTRBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TRMTR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TRMTR>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TRMTR> CreateTRMTR(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t res_0 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Model::Material>>> materials = 0) {
  TRMTRBuilder builder_(_fbb);
  builder_.add_materials(materials);
  builder_.add_res_0(res_0);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TRMTR> CreateTRMTRDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t res_0 = 0,
    const std::vector<::flatbuffers::Offset<Titan::Model::Material>> *materials = nullptr) {
  auto materials__ = materials ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Model::Material>>(*materials) : 0;
  return Titan::Model::CreateTRMTR(
      _fbb,
      res_0,
      materials__);
}

inline const Titan::Model::TRMTR *GetTRMTR(const void *buf) {
  return ::flatbuffers::GetRoot<Titan::Model::TRMTR>(buf);
}

inline const Titan::Model::TRMTR *GetSizePrefixedTRMTR(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Titan::Model::TRMTR>(buf);
}

inline bool VerifyTRMTRBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Titan::Model::TRMTR>(nullptr);
}

inline bool VerifySizePrefixedTRMTRBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Titan::Model::TRMTR>(nullptr);
}

inline const char *TRMTRExtension() {
  return "trmtr";
}

inline void FinishTRMTRBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRMTR> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTRMTRBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Model::TRMTR> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Model
}  // namespace Titan

#endif  // FLATBUFFERS_GENERATED_TRMTR_TITAN_MODEL_H_
